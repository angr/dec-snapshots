{"4198400:_init": "extern struct_0 *g_4033b8;\n
\n
long long _init()\n
{\n
    struct struct_0 **v1;  // rax\n
\n
    v1 = g_4033b8;\n
    if (g_4033b8)\n
        v1 = g_4033b8();\n
    return v1;\n
}\n
", "4198432:sub_401020": "extern unsigned long long g_4033d8;\n
\n
long long sub_401020()\n
{\n
    unsigned long long v0;  // [sp-0x8]\n
\n
    v0 = g_4033d8;\n
    goto *(4207584);\n
}\n
", "4198444:sub_40102c": "int sub_40102c()\n
{\n
    cgc__terminate();\n
    return;\n
}\n
", "4198448:cgc__terminate": "// attributes: PLT stub\n
int cgc__terminate()\n
{\n
    ::libc.so.0::cgc__terminate();\n
    return;\n
}\n
", "4198464:cgc_transmit": "// attributes: PLT stub\n
int cgc_transmit()\n
{\n
    ::libc.so.0::cgc_transmit();\n
    return;\n
}\n
", "4198480:cgc_allocate": "// attributes: PLT stub\n
int cgc_allocate()\n
{\n
    ::libc.so.0::cgc_allocate();\n
    return;\n
}\n
", "4198496:cgc_deallocate": "// attributes: PLT stub\n
int cgc_deallocate()\n
{\n
    ::libc.so.0::cgc_deallocate();\n
    return;\n
}\n
", "4198512:cgc_receive": "// attributes: PLT stub\n
int cgc_receive()\n
{\n
    ::libc.so.0::cgc_receive();\n
    return;\n
}\n
", "4198528:__cxa_finalize": "// attributes: PLT stub\n
char * __cxa_finalize()\n
{\n
    goto *(4207560);\n
}\n
", "4198544:_start": "long long _start()\n
{\n
    unsigned long long v0;  // [sp+0x0]\n
    unsigned long v1;  // [bp+0x8]\n
    unsigned long v2;  // rax\n
    unsigned long long v3;  // rdx\n
\n
    v0 = v2;\n
    __libc_start_main(main, v0, &v1, 0, 0, v3); /* do not return */\n
}\n
", "4198581:sub_4010b5": "long long sub_4010b5()\n
{\n
    [D] Unsupported jumpkind Ijk_SigTRAP at address 4198581()\n
}\n
", "4198582:sub_4010b6": "int sub_4010b6()\n
{\n
    deregister_tm_clones();\n
    return;\n
}\n
", "4198592:deregister_tm_clones": "extern unsigned long long g_4033b0;\n
\n
long long deregister_tm_clones()\n
{\n
    return 4209608;\n
}\n
", "4198633:sub_4010e9": "int sub_4010e9()\n
{\n
    register_tm_clones();\n
    return;\n
}\n
", "4198640:register_tm_clones": "extern unsigned long long g_4033c0;\n
\n
long long register_tm_clones()\n
{\n
    return 0;\n
}\n
", "4198697:sub_401129": "int sub_401129()\n
{\n
    __do_global_dtors_aux();\n
    return;\n
}\n
", "4198704:__do_global_dtors_aux": "extern char __bss_start;\n
extern unsigned long long g_4033c8;\n
\n
long long __do_global_dtors_aux()\n
{\n
    unsigned long v0;  // [sp-0x8]\n
    unsigned long v3;  // rax\n
\n
    if (__bss_start)\n
        return v3;\n
    *(&v0) = vvar_7{reg 56};\n
    if (!g_4033c8)\n
    {\n
        __bss_start = 1;\n
        return deregister_tm_clones();\n
    }\n
    __cxa_finalize();\n
}\n
", "4198757:sub_401165": "int sub_401165()\n
{\n
}\n
", "4198761:sub_401169": "int sub_401169()\n
{\n
    frame_dummy();\n
    return;\n
}\n
", "4198768:frame_dummy": "long long frame_dummy()\n
{\n
    return register_tm_clones();\n
}\n
", "4198777:sub_401179": "int sub_401179()\n
{\n
    cgc_transmit_all();\n
    return;\n
}\n
", "4198784:cgc_transmit_all": "long long cgc_transmit_all(unsigned long long a0, unsigned long a1)\n
{\n
    unsigned int v0;  // [sp-0x34]\n
    void* v1;  // [sp-0x30]\n
    void* v2;  // [sp-0x28]\n
    void* v3;  // [sp-0x10]\n
\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v3 = 0;\n
        return v3;\n
    }\n
    do\n
    {\n
        v0 = cgc_transmit(1, a0, a1 - v1, &v2);\n
        if (!v0 && !(!v2))\n
            continue;\n
        cgc__terminate(1);\n
        v1 = v2 + v1;\n
    } while (v1 < a1);\n
    v3 = a1;\n
    return v3;\n
}\n
", "4198956:sub_40122c": "int sub_40122c()\n
{\n
    main();\n
    return;\n
}\n
", "4198960:main": "extern unsigned long long gHelpMsg;\n
\n
int main(unsigned int a0, unsigned long a1)\n
{\n
    unsigned long long v0;  // [sp-0x78]\n
    char v1;  // [sp-0x6d]\n
    unsigned int v2;  // [sp-0x6c]\n
    unsigned int v3;  // [sp-0x68]\n
    unsigned int v4;  // [sp-0x64]\n
    void* v5;  // [sp-0x60]\n
    void* v6;  // [sp-0x58]\n
    void* v7;  // [sp-0x50], Other Possible Types: unsigned int *\n
    void* v8;  // [sp-0x48], Other Possible Types: unsigned int *\n
    unsigned int v9;  // [sp-0x40]\n
    unsigned int v10;  // [sp-0x3c]\n
    unsigned int v11;  // [sp-0x38]\n
    unsigned int v12;  // [sp-0x34]\n
    void* v13;  // [sp-0x30]\n
    void* v14;  // [sp-0x28]\n
    unsigned int v15;  // [sp-0x1c]\n
    unsigned long long v16;  // [sp-0x18]\n
    unsigned int v17;  // [sp-0x10]\n
    unsigned int v18;  // [sp-0xc]\n
    unsigned int v20;  // 4101\n
\n
    v18 = 0;\n
    v17 = a0;\n
    v16 = a1;\n
    v15 = 0;\n
    v14 = 0;\n
    v13 = 0;\n
    v12 = -1;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    cgc_allocate(0x1000, 0, &v6);\n
    cgc_allocate(0x1000, 0, &v7);\n
    cgc_allocate(0x1000, 0, &v5);\n
    cgc_allocate(0x2000, 0, &v8);\n
    cgc_deallocate(v6, 0x1000);\n
    cgc_deallocate(v5, 0x1000);\n
    do\n
    {\n
        v13 = 0;\n
        do\n
        {\n
            v9 = cgc_receive(0, &v15 + v13, 4 - v13, &v14);\n
            if (!v9 && !(!v14))\n
                continue;\n
            if (!v11)\n
                cgc_transmit_all(\"### The Instruction Set\\n
\\n
000b : PUSH # : Pushes a new number onto the stack\\n
001b : POP : Pops the top number from the stack\\n
010b : PUSHPC : Pushes the program counter of the current instruction (i.e. PUSHPC) onto the stack\\n
011b : JMPZ : Pops the top number off of the stack, if its 0 then pop the next value off of the stack and store t\\n
hat into the PC. If it is not-zero then just pop the next value off of the stack and do nothing with it.\\n
100b : SWAP # : Swaps the nth number with the top one (which is 0) - meaning SWAP 0 does nothing\\n
101b : DUP #: Duplicates nth number and pushes it to the top of the stack\\n
110b : ADD : Pops the top two numbers off of the stack, adds them, and pushes the sum back onto the stack\\n
111b : SUB : Pops the top two numbers off of the stack, subtracts them ( (top - 1) - top ), and pushes the differ\\n
ence back onto the stack\\n
\\n
All instructions are 32-bits long with the first 3 bits (msbs) reserved for the instruction and the lower 29 bits\\n
for literals. POP, ADD, SUB, PUSHPC, JMPZ ignores the lower 29 bits, UNLESS the following special instructions a\\n
re used:\\n
\\n
0xFFFFFFFF : RET : End of instruction stream - The topmost value is the return value\\n
\\n
### A simple program\\n
\\n
multiply(x,y)\\n
\\n
PUSH 0\\t; 0 - the SUM\\n
PUSH y \\t; SUM, y\\n
PUSHPC \\t; SUM, y, pc\\n
DUP 1 \\t; SUM, y, pc, y\\n
PUSH 1\\t; SUM, y, pc, y, 1\\n
SUB\\t; SUM, y, pc, y-1\\n
SWAP 2\\t; SUM, y-1, pc, y\\n
SWAP 3\\t; y, y-1, pc, SUM\\n
PUSH x \\t; y, y-1, pc, SUM, x\\n
ADD \\t; y, y-1, pc, SUM+x\\n
SWAP 3 \\t; SUM+x, y-1, pc, y\\n
POP\\t; SUM+x, y-1, pc\\n
PUSHPC\\t; SUM+x, y-1, pc, HERE\\n
PUSH 7\\t; SUM+x, y-1, pc, HERE, 7\\n
ADD\\t; SUM+x, y-1, pc, HERE+7 \\n
DUP 2\\t; SUM+x, y-1, pc, HERE+7, y-1\\n
JMPZ\\t;\\n
PUSH 0\\t; SUM+x, y-1, pc, 0\\n
JMPZ\\t;\\n
POP\\t; SUM+x, y-1\\n
POP\\t; SUM+x\\n
RET\\n
\\n
If y-1 is not zero, then we will jump back up to where PUSHPC is and execute that whole stream again, except SUM \\n
will now be SUM+x and y is now y-1\\n
If y-1 is zero, then we will jump to the instruction after the second JMPZ (which is the first POP)\\n
\", 1956);\n
            cgc__terminate(4294967295);\n
            v13 = v14 + v13;\n
        } while (v13 < 4);\n
        v8[v11] = v15;\n
        v11 += 1;\n
        if (v11 >= 0x800)\n
        {\n
            cgc_transmit_all(\"INSNS OVERFLOW EXCEPTION\\n
\", 26);\n
            cgc__terminate(4294967295);\n
        }\n
    } while (v15 != -1);\n
    v10 = 0;\n
    while (true)\n
    {\n
        v20 = v11;\n
        v1 = 0;\n
        if (v10 < v20)\n
            v1 = v8[v10] != -1;\n
        if (!(v1 & 1))\n
            break;\n
        v15 = v8[v10];\n
        if (v15 == -1)\n
            break;\n
        v0 = v15 & 7;\n
        switch (v0)\n
        {\n
        case 0:\n
            v12 += 1;\n
            v7[v12] = v15 >> 3;\n
            goto LABEL_401717;\n
        case 1:\n
            if (v12 < 0)\n
            {\n
                cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
                cgc__terminate(4294967295);\n
            }\n
            v12 -= 1;\n
            goto LABEL_401717;\n
        case 2:\n
            v12 += 1;\n
            if (v12 >= 0x400)\n
            {\n
                cgc_transmit_all(\"STACK OVERFLOW EXCEPTION\\n
\", 26);\n
                cgc__terminate(4294967295);\n
            }\n
            v7[v12] = v10;\n
            goto LABEL_401717;\n
        case 3:\n
            if (v12 < 1)\n
            {\n
                cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
                cgc__terminate(4294967295);\n
            }\n
            if (v7[v12])\n
            {\n
                v12 -= 2;\n
                goto LABEL_401717;\n
            }\n
            v10 = v7[1 + v12];\n
            if (v10 >= 0 && v10 < v11)\n
                goto LABEL_40154a;\n
            cgc_transmit_all(\"INVALID PROGRAM COUNTER EXCEPTION\\n
\", 35);\n
            cgc__terminate(4294967295);\n
LABEL_40154a:\n
            v10 -= 1;\n
            break;\n
        case 4:\n
            if (v12 < 0)\n
            {\n
                cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
                cgc__terminate(4294967295);\n
            }\n
            v4 = v7[v12];\n
            v3 = v12 - (v15 >> 3);\n
            if (v3 >= 0 && v3 <= v12)\n
                goto LABEL_4015d3;\n
            cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
            cgc__terminate(4294967295);\n
LABEL_4015d3:\n
            v7[v12] = v7[v3];\n
            v7[v3] = v4;\n
            goto LABEL_401717;\n
        case 5:\n
            v12 += 1;\n
            v2 = v12 - (v15 >> 3) - 1;\n
            if (v2 >= 0 && v2 <= v12)\n
                goto LABEL_401647;\n
            cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
            cgc__terminate(4294967295);\n
LABEL_401647:\n
            v7[v12] = v7[1 + v12 + -1 * (v15 >> 3)];\n
            goto LABEL_401717;\n
        case 6:\n
            if (v12 < 1)\n
            {\n
                cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
                cgc__terminate(4294967295);\n
            }\n
            v7[1 + v12] = v7[v12] + v7[1 + v12];\n
            v12 -= 1;\n
            goto LABEL_401717;\n
        case 7:\n
            if (v12 < 1)\n
            {\n
                cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
                cgc__terminate(4294967295);\n
            }\n
            v7[1 + v12] = v7[1 + v12] - v7[v12];\n
            v12 -= 1;\n
            goto LABEL_401717;\n
        default:\n
LABEL_401717:\n
            v10 += 1;\n
            continue;\n
        }\n
    }\n
    if (v12 < 0)\n
    {\n
        cgc_transmit_all(\"STACK UNDERFLOW EXCEPTION\\n
\", 27);\n
        cgc__terminate(4294967295);\n
    }\n
    cgc_transmit_all(&v7[v12], 4);\n
    return 0;\n
}\n
", "4200304:_fini": "long long _fini()\n
{\n
    unsigned long v1;  // rax\n
\n
    return v1;\n
}\n
", "5242880:__libc_start_main": null, "5242888:cgc__terminate": null, "5242896:cgc_transmit": null, "5242904:cgc_allocate": null, "5242912:cgc_deallocate": null, "5242920:cgc_receive": null, "6295632:UnresolvableJumpTarget": null, "6295640:UnresolvableCallTarget": null}