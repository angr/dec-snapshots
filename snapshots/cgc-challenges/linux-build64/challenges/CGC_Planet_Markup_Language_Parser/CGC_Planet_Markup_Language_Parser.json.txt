{"4202496:_init": "extern struct_0 *g_4137a0;\n
\n
long long _init()\n
{\n
    struct struct_0 **v1;  // rax, Other Possible Types: unsigned long\n
\n
    v1 = g_4137a0;\n
    if (g_4137a0)\n
        v1 = g_4137a0();\n
    return v1;\n
}\n
", "4202528:sub_402020": "extern unsigned long long g_4137c0;\n
\n
long long sub_402020()\n
{\n
    unsigned long v0;  // [bp-0x8]\n
\n
    v0 = g_4137c0;\n
    goto *(4274120);\n
}\n
", "4202540:sub_40202c": null, "4202544:cgc_pow": "// attributes: PLT stub\n
int cgc_pow()\n
{\n
    ::libc.so.0::cgc_pow();\n
    return;\n
}\n
", "4202560:cgc__terminate": "// attributes: PLT stub\n
int cgc__terminate()\n
{\n
    ::libc.so.0::cgc__terminate();\n
    return;\n
}\n
", "4202576:cgc_transmit": "// attributes: PLT stub\n
int cgc_transmit()\n
{\n
    ::libc.so.0::cgc_transmit();\n
    return;\n
}\n
", "4202592:cgc_allocate": "// attributes: PLT stub\n
int cgc_allocate()\n
{\n
    ::libc.so.0::cgc_allocate();\n
    return;\n
}\n
", "4202608:cgc_rint": "// attributes: PLT stub\n
int cgc_rint()\n
{\n
    ::libc.so.0::cgc_rint();\n
    return;\n
}\n
", "4202624:cgc_deallocate": "// attributes: PLT stub\n
int cgc_deallocate()\n
{\n
    ::libc.so.0::cgc_deallocate();\n
    return;\n
}\n
", "4202640:cgc_log10": "// attributes: PLT stub\n
int cgc_log10()\n
{\n
    ::libc.so.0::cgc_log10();\n
    return;\n
}\n
", "4202656:cgc_receive": "// attributes: PLT stub\n
int cgc_receive()\n
{\n
    ::libc.so.0::cgc_receive();\n
    return;\n
}\n
", "4202672:__cxa_finalize": "// attributes: PLT stub\n
char * __cxa_finalize()\n
{\n
    goto *(4274096);\n
}\n
", "4202688:_start": "long long _start()\n
{\n
    unsigned long v0;  // [bp+0x0], Other Possible Types: char\n
    unsigned long v1;  // [bp+0x8]\n
    unsigned long long v2;  // rsi\n
    unsigned long v3;  // rax\n
    unsigned long long v4;  // rdx\n
\n
    v2 = *(&v0);\n
    v0 = v3;\n
    __libc_start_main(main, v2, &v1, 0, 0, v4); /* do not return */\n
}\n
", "4202725:sub_4020e5": null, "4202726:sub_4020e6": null, "4202736:deregister_tm_clones": "extern char __bss_start;\n
extern unsigned long long g_413798;\n
\n
long long deregister_tm_clones()\n
{\n
    return &__bss_start;\n
}\n
", "4202777:sub_402119": null, "4202784:register_tm_clones": "extern unsigned long long g_4137a8;\n
\n
long long register_tm_clones()\n
{\n
    return 0;\n
}\n
", "4202841:sub_402159": null, "4202848:__do_global_dtors_aux": "extern char __bss_start;\n
extern unsigned long long g_4137b0;\n
\n
long long __do_global_dtors_aux()\n
{\n
    unsigned long v0;  // [bp-0x8]\n
    unsigned long v2;  // rax\n
\n
    if (__bss_start)\n
        return v2;\n
    *(&v0) = rbp<8>;\n
    if (!g_4137b0)\n
    {\n
        __bss_start = 1;\n
        return deregister_tm_clones();\n
    }\n
    __cxa_finalize();\n
}\n
", "4202901:sub_402195": null, "4202905:sub_402199": null, "4202912:frame_dummy": "long long frame_dummy()\n
{\n
    return register_tm_clones();\n
}\n
", "4202921:sub_4021a9": null, "4202928:cgc_floor": "long long cgc_floor()\n
{\n
    unsigned long v0;  // [bp-0x18]\n
    int tmp_3;  // tmp #3\n
    int tmp_5;  // tmp #5\n
    int tmp_4;  // tmp #4\n
    int tmp_8;  // tmp #8\n
    int tmp_10;  // tmp #10\n
    int tmp_9;  // tmp #9\n
    void* v1;  // [bp-0x10], Other Possible Types: unsigned long\n
    unsigned long v3;  // xmm0lq\n
    unsigned long v5;  // rax, Other Possible Types: unsigned long long\n
    int v8;  // xmm0\n
\n
    v0 = v3;\n
    if ((((CmpF(v0, 0) & 69) | ((CmpF(v0, 0) & 69) >> 6)) & 1) != 1)\n
    {\n
        v5 = cgc_rint();\n
        tmp_3 = SubV(tmp_5, tmp_4);\n
        *(&v1) = tmp_3;\n
        return v5;\n
    }\n
    else if ((((CmpF(0, v0) & 69) | ((CmpF(0, v0) & 69) >> 6)) & 1) != 1)\n
    {\n
        tmp_8 = SubV(tmp_10, tmp_9);\n
        v5 = cgc_rint();\n
        v8 = tmp_8 + (0 CONCAT 0x3ff0000000000000);\n
        v1 = v8;\n
        return v5;\n
    }\n
    else\n
    {\n
        v1 = 0;\n
        return v5;\n
    }\n
}\n
", "4203076:sub_402244": null, "4203088:cgc_round_away_from_zero": "long long cgc_round_away_from_zero()\n
{\n
    unsigned long v0;  // [bp-0x18]\n
    int tmp_8;  // tmp #8\n
    int tmp_10;  // tmp #10\n
    int tmp_9;  // tmp #9\n
    void* v1;  // [bp-0x10], Other Possible Types: unsigned long\n
    unsigned long v3;  // xmm0lq\n
    unsigned long v5;  // rax, Other Possible Types: unsigned long long\n
\n
    v0 = v3;\n
    if ((((CmpF(v0, 0) & 69) | ((CmpF(v0, 0) & 69) >> 6)) & 1) != 1)\n
    {\n
        v5 = cgc_rint();\n
        s_10 =L Conv(128->64, ((0x0<64> CONCAT 0x3fe0000000000000<64>) + Conv(64->128, Load(addr=stack_base-24, size=8, endness=Iend_LE))))<8>\n
        return v5;\n
    }\n
    else if ((((CmpF(0, v0) & 69) | ((CmpF(0, v0) & 69) >> 6)) & 1) != 1)\n
    {\n
        tmp_8 = SubV(tmp_10, tmp_9);\n
        v5 = cgc_rint();\n
        *(&v1) = tmp_8;\n
        return v5;\n
    }\n
    else\n
    {\n
        v1 = 0;\n
        return v5;\n
    }\n
}\n
", "4203212:sub_4022cc": null, "4203216:cgc_round": "double cgc_round()\n
{\n
    unsigned long long v0;  // [bp-0x28]\n
    unsigned long long v1;  // [bp-0x20]\n
    unsigned long v2;  // [bp-0x18]\n
    unsigned long v4;  // xmm1lq\n
    unsigned long long v5;  // rdi\n
    unsigned long long v6;  // rsi\n
    unsigned long long v7;  // rdx\n
    unsigned long long v8;  // rcx\n
    unsigned long long v9;  // r8\n
    unsigned long long v10;  // r9\n
    unsigned long v11;  // xmm0lq\n
\n
    v2 = v4;\n
    cgc_rint();\n
    v2 = v2;\n
    cgc_pow(v5, v6, v7, v8, v9, v10);\n
    v1 = 0x4024000000000000;\n
    cgc_pow(v5, v6, v7, v8, v9, v10);\n
    v0 = 0x4024000000000000;\n
    cgc_round_away_from_zero();\n
    return Conv(128->64, (((0x0<64> CONCAT xmm0lq<8>) * Conv(64->128, Load(addr=stack_base-32, size=8, endness=Iend_LE))) * Conv(64->128, Load(addr=stack_base-40, size=8, endness=Iend_LE))));\n
}\n
", "4203344:cgc_putc": "long long cgc_putc(unsigned long long a0)\n
{\n
    unsigned long long v1;  // rsi\n
    unsigned long long v2;  // rdx\n
    unsigned long long v3;  // rcx\n
\n
    if (cgc_transmit(a0, v1, v2, v3))\n
    {\n
        cgc__terminate(a0);\n
        return a0;\n
    }\n
    return a0;\n
}\n
", "4203406:sub_40238e": null, "4203408:cgc_int_to_str": "typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
long long cgc_int_to_str(unsigned long a0, struct_0 *a1)\n
{\n
    unsigned int v0;  // [bp-0x44]\n
    struct_0 *v1;  // [bp-0x40], Other Possible Types: unsigned long\n
    char v2;  // [bp-0x38]\n
    struct_0 *v3;  // [bp-0x18], Other Possible Types: unsigned long\n
    unsigned int v4;  // [bp-0xc], Other Possible Types: unsigned long\n
    unsigned int v7;  // eax\n
    unsigned int v9;  // eax\n
\n
    v4 = a0;\n
    v3 = a1;\n
    v1 = &v2;\n
    v0 = 0;\n
    if (!v3)\n
        return &v2;\n
    if (v4 < 0)\n
    {\n
        v3->field_0 = 45;\n
        v3 += 1;\n
        v4 *= -1;\n
    }\n
    do\n
    {\n
        *(v1) = ((v4 >> 31 CONCAT v4) /m 10 >> 32) + 48;\n
        v7 = v4;\n
        v4 = (v7 >> 31 CONCAT v7) /m 10;\n
        v1 += 1;\n
        v0 += 1;\n
    } while (v4);\n
    while (true)\n
    {\n
        v9 = v0;\n
        v0 = v9 - 1;\n
        if (v9 <= 0)\n
            break;\n
        v1 -= 1;\n
        *(v3) = *(v1);\n
        v3 += 1;\n
    }\n
    *(v3) = 0;\n
    return v3;\n
}\n
", "4203633:sub_402471": null, "4203648:cgc_float_to_str": "long long cgc_float_to_str(char *a0)\n
{\n
    int tmp_7;  // tmp #7\n
    int tmp_9;  // tmp #9\n
    int tmp_8;  // tmp #8\n
    int tmp_12;  // tmp #12\n
    int tmp_13;  // tmp #13\n
    int tmp_10;  // tmp #10\n
    char v0;  // [bp-0x42]\n
    char v1;  // [bp-0x41]\n
    unsigned long long v2;  // [bp-0x40]\n
    char *v3;  // [bp-0x38], Other Possible Types: unsigned long\n
    unsigned int v4;  // [bp-0x30]\n
    unsigned int v5;  // [bp-0x2c]\n
    unsigned int v6;  // [bp-0x28]\n
    unsigned int v7;  // [bp-0x20]\n
    unsigned int v8;  // [bp-0x1c]\n
    unsigned long v9;  // [bp-0x10]\n
    char v10;  // [bp-0x8]\n
    unsigned long long v12;  // rbp\n
    unsigned long v13;  // xmm0lq\n
    char *v14;  // rax, Other Possible Types: unsigned long long, unsigned long\n
    unsigned long long v15;  // xmm0lq\n
    char *v16;  // rax\n
    int v18;  // xmm0, Other Possible Types: unsigned long long\n
    char *v19;  // rax\n
    char *v20;  // rax\n
    char *v21;  // rax\n
\n
    v12 = &v10;\n
    v9 = v13;\n
    if (!a0)\n
    {\n
        return v14;\n
    }\n
    else if (!cgc_isnan())\n
    {\n
        if (cgc_isinf())\n
        {\n
            v14 = cgc_strcpy(a0, \"inf\");\n
        }\n
        else\n
        {\n
            v15 = v9;\n
            if ((((CmpF(v15, 0) & 69) >> 6) & 1) == 1 && !([D] amd64g_calculate_condition(0xa<64>, 0x0<64>, Conv(32->64, ((xmm0lq<8> CmpF 0x0<64>) & 0x45<32>)), 0x0<64>, cc_ndep<8>)))\n
            {\n
                v14 = cgc_strcpy(a0, \"0.00000\");\n
                goto LABEL_40277c;\n
            }\n
            v4 = 0;\n
            v3 = a0;\n
            v18 = v9;\n
            if ((((CmpF(v18, 0) & 69) | ((CmpF(v18, 0) & 69) >> 6)) & 1) == 1)\n
            {\n
                tmp_7 = SubV(tmp_9, tmp_8);\n
                v18 = tmp_7;\n
                v9 = v18;\n
            }\n
            else\n
            {\n
                s_10 =L Conv(128->64, ((0x0<64> CONCAT 0x3ed4f8b588e368f1<64>) + Conv(64->128, Load(addr=stack_base-16, size=8, endness=Iend_LE))))<8>\n
            }\n
            if ((((CmpF(0, v9) & 69) | ((CmpF(0, v9) & 69) >> 6)) & 1) != 1)\n
            {\n
                v4 = 1;\n
                v16 = v3;\n
                v3 = v16 + 1;\n
                *(v16) = 45;\n
                v9 ^= 0x8000000000000000;\n
            }\n
            cgc_log10();\n
            v7 = v9;\n
            if ((((CmpF(0x3ff0000000000000, v7) & 69) | ((CmpF(0x3ff0000000000000, v7) & 69) >> 6)) & 1) != 1)\n
                v7 = 0;\n
            v6 = 0;\n
            v5 = 0;\n
            while (true)\n
            {\n
                *(&v18) = v9;\n
                v1 = 1;\n
                if ((((CmpF(v18, 4532020583610935537) & 69) | ((CmpF(v18, 4532020583610935537) & 69) >> 6)) & 1) == 1)\n
                    v1 = 0 <= v7;\n
                if (!(v1 & 1))\n
                    break;\n
                cgc_pow();\n
                v2 = 0x4024000000000000;\n
                *(&v18) = v2;\n
                if ((((CmpF(v18, 0) & 69) | ((CmpF(v18, 0) & 69) >> 6)) & 1) != 1 && !cgc_isinf())\n
                {\n
                    tmp_12 = DivV(tmp_13, tmp_10);\n
                    v18 = tmp_12;\n
                    cgc_floor();\n
                    v8 = v18;\n
                    v9 = (0 CONCAT v8 ^ 0x8000000000000000) * (0 CONCAT v2) + (0 CONCAT v9);\n
                    v19 = v3;\n
                    v3 = v19 + 1;\n
                    *(v19) = v8 + 48;\n
                    if (v5)\n
                        v6 += 1;\n
                }\n
                if (!v7)\n
                {\n
                    *(&v18) = v9;\n
                    if ((((CmpF(v18, 0) & 69) | ((CmpF(v18, 0) & 69) >> 6)) & 1) != 1)\n
                    {\n
                        v20 = v3;\n
                        v3 = v20 + 1;\n
                        *(v20) = 46;\n
                        v5 = 1;\n
                        v6 = 0;\n
                    }\n
                }\n
                v7 -= 1;\n
            }\n
            while (true)\n
            {\n
                v0 = 0;\n
                if (v5)\n
                    v0 = v6 < 5;\n
                if (!(v0 & 1))\n
                    break;\n
                v21 = v3;\n
                v3 = v21 + 1;\n
                *(v21) = 48;\n
                v6 += 1;\n
            }\n
            v14 = v3;\n
            *(v14) = 0;\n
LABEL_40277c:\n
        }\n
        return v14;\n
    }\n
    else\n
    {\n
        v14 = cgc_strcpy(a0, \"nan\");\n
        return v14;\n
    }\n
}\n
", "4204428:sub_40278c": null, "4204432:cgc_vprintf": "typedef struct struct_1 {\n
    unsigned int field_0;\n
    unsigned int field_4;\n
    struct struct_2 *field_8;\n
    unsigned long long field_10;\n
} struct_1;\n
\n
typedef struct struct_3 {\n
    char field_0;\n
} struct_3;\n
\n
typedef struct struct_2 {\n
    struct struct_0 *field_0;\n
} struct_2;\n
\n
typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
long long cgc_vprintf(char *a0, struct_1 *a1)\n
{\n
    struct struct_0 **v0;  // [bp-0xe0], Other Possible Types: unsigned long\n
    struct_1 *v1;  // [bp-0xd8]\n
    unsigned int v2;  // [bp-0xcc]\n
    unsigned long long *v3;  // [bp-0xc8], Other Possible Types: unsigned long\n
    struct_1 *v4;  // [bp-0xc0]\n
    unsigned int *v5;  // [bp-0xb8]\n
    unsigned int v6;  // [bp-0xac]\n
    unsigned int *v7;  // [bp-0xa8], Other Possible Types: unsigned long\n
    struct_1 *v8;  // [bp-0xa0]\n
    unsigned int v9;  // [bp-0x98]\n
    unsigned int v10;  // [bp-0x94]\n
    char *v11;  // [bp-0x90], Other Possible Types: unsigned long\n
    struct_3 *v12;  // [bp-0x88], Other Possible Types: unsigned long\n
    unsigned long v13;  // [bp-0x80]\n
    struct_3 *v14;  // [bp-0x78], Other Possible Types: unsigned long\n
    unsigned int v15;  // [bp-0x6c]\n
    char v16;  // [bp-0x68]\n
    unsigned int v17;  // [bp-0x24]\n
    char *v18;  // [bp-0x18], Other Possible Types: unsigned long\n
    unsigned int v19;  // [bp-0xc]\n
    struct_1 *v21;  // rcx\n
    unsigned long long v22;  // rdx\n
    unsigned int *v23;  // rax\n
    struct_1 *v24;  // rcx\n
    unsigned int *v25;  // rdx\n
    unsigned long long v26;  // rdx\n
    unsigned long long *v27;  // rax\n
    struct_1 *v28;  // rcx\n
    unsigned long long *v29;  // rdx\n
    struct_1 *v30;  // rcx\n
    unsigned long long v31;  // rdx\n
    struct struct_0 **v32;  // rax\n
    struct_1 *v33;  // rcx\n
    struct struct_0 **v34;  // rdx\n
\n
    v18 = a0;\n
    v17 = 0;\n
    if (!v18)\n
    {\n
        v19 = -1;\n
        return v19;\n
    }\n
    while (true)\n
    {\n
        if (!*(v18))\n
        {\n
            v19 = v17;\n
            return v19;\n
        }\n
        else if (*(v18) != 64)\n
        {\n
            cgc_putc(*(v18));\n
            v18 += 1;\n
            v17 += 1;\n
        }\n
        else\n
        {\n
            v18 += 1;\n
            v10 = *(v18);\n
            if (!v10)\n
            {\n
                v19 = -1;\n
                return v19;\n
            }\n
            if (v10 == 64)\n
            {\n
                cgc_putc(64);\n
            }\n
            else if (v10 == 100)\n
            {\n
                v8 = a1;\n
                v9 = v8->field_0;\n
                if (v9 > 40)\n
                {\n
                    v24 = v8;\n
                    v25 = v24->field_8;\n
                    v24->field_8 = &v25[2];\n
                    v7 = v25;\n
                }\n
                else\n
                {\n
                    v21 = v8;\n
                    v22 = v9;\n
                    v23 = v22 + v21->field_10;\n
                    v21->field_0 = v22 + 8;\n
                    v7 = v23;\n
                }\n
                v15 = *(v7);\n
                cgc_int_to_str(v15, &v16);\n
                for (v14 = &v16; v14->field_0; v14 += 1)\n
                {\n
                    cgc_putc(v14->field_0);\n
                    v17 += 1;\n
                }\n
            }\n
            else if (v10 == 102)\n
            {\n
                v4 = a1;\n
                v5 = &v4->field_4;\n
                v6 = v4->field_4;\n
                if (v6 > 160)\n
                {\n
                    v28 = v4;\n
                    v29 = v28->field_8;\n
                    v28->field_8 = &v29[1];\n
                    v3 = v29;\n
                }\n
                else\n
                {\n
                    v26 = v6;\n
                    v27 = v26 + v4->field_10;\n
                    *(v5) = v26 + 16;\n
                    v3 = v27;\n
                }\n
                v13 = *(v3);\n
                cgc_float_to_str(&v16);\n
                for (v12 = &v16; v12->field_0; v12 += 1)\n
                {\n
                    cgc_putc(v12->field_0);\n
                    v17 += 1;\n
                }\n
            }\n
            else if (v10 == 115)\n
            {\n
                v1 = a1;\n
                v2 = v1->field_0;\n
                if (v2 > 40)\n
                {\n
                    v33 = v1;\n
                    v34 = v33->field_8;\n
                    v33->field_8 = &v34[1];\n
                    v0 = v34;\n
                }\n
                else\n
                {\n
                    v30 = v1;\n
                    v31 = v2;\n
                    v32 = v31 + v30->field_10;\n
                    v30->field_0 = v31 + 8;\n
                    v0 = v32;\n
                }\n
                for (v11 = *(v0); *(v11); v11 += 1)\n
                {\n
                    cgc_putc(*(v11));\n
                    v17 += 1;\n
                }\n
            }\n
            else\n
            {\n
                v19 = -1;\n
                return v19;\n
            }\n
            v18 += 1;\n
        }\n
    }\n
}\n
", "4205318:sub_402b06": null, "4205328:cgc_printf": "long long cgc_printf(char *a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4)\n
{\n
    char v0;  // [bp-0xe8]\n
    unsigned long v1;  // [bp-0xe0]\n
    unsigned long v2;  // [bp-0xd8]\n
    unsigned long v3;  // [bp-0xd0]\n
    unsigned long v4;  // [bp-0xc8]\n
    unsigned long v5;  // [bp-0xc0]\n
    int v6;  // [bp-0xb8]\n
    int v7;  // [bp-0xa8]\n
    int v8;  // [bp-0x98]\n
    int v9;  // [bp-0x88]\n
    int v10;  // [bp-0x78]\n
    int v11;  // [bp-0x68]\n
    int v12;  // [bp-0x58]\n
    int v13;  // [bp-0x48]\n
    unsigned int v14;  // [bp-0x2c]\n
    unsigned int v15;  // [bp-0x28]\n
    unsigned int v16;  // [bp-0x24]\n
    unsigned long v17;  // [bp-0x20]\n
    unsigned long v18;  // [bp-0x18]\n
    unsigned long v19;  // [bp+0x8]\n
    char v20;  // al\n
    int v21;  // xmm0\n
    int v22;  // xmm1\n
    int v23;  // xmm2\n
    int v24;  // xmm3\n
    int v25;  // xmm4\n
    int v26;  // xmm5\n
    int v27;  // xmm6\n
    int v28;  // xmm7\n
    unsigned long v29;  // r9\n
\n
    if (v20)\n
    {\n
        v6 = v21;\n
        v7 = v22;\n
        v8 = v23;\n
        v9 = v24;\n
        v10 = v25;\n
        v11 = v26;\n
        v12 = v27;\n
        v13 = v28;\n
    }\n
    v5 = v29;\n
    v4 = a4;\n
    v3 = a3;\n
    v2 = a2;\n
    v1 = a1;\n
    v18 = &v0;\n
    v17 = &v19;\n
    v16 = 48;\n
    v15 = 8;\n
    v14 = cgc_vprintf(a0, &v15);\n
    return v14;\n
}\n
", "4205488:cgc_memcpy": "long long cgc_memcpy(unsigned long a0, unsigned long a1, unsigned long a2)\n
{\n
    char *v0;  // [bp-0x28], Other Possible Types: unsigned long\n
\n
    for (v0 = 0; v0 < a2; v0 += 1)\n
    {\n
        v0[a0] = v0[a1];\n
    }\n
    return v0;\n
}\n
", "4205571:sub_402c03": null, "4205584:cgc_islower": "long long cgc_islower(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (a0 >= 97 && a0 <= 122)\n
    {\n
        v0 = 1;\n
        return v0;\n
    }\n
    v0 = 0;\n
    return v0;\n
}\n
", "4205635:sub_402c43": null, "4205648:cgc_isupper": "long long cgc_isupper(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (a0 >= 65 && a0 <= 90)\n
    {\n
        v0 = 1;\n
        return v0;\n
    }\n
    v0 = 0;\n
    return v0;\n
}\n
", "4205699:sub_402c83": null, "4205712:cgc_isalpha": "long long cgc_isalpha(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0x10]\n
\n
    v0 = cgc_islower(a0);\n
    return v0 | cgc_isupper(a0);\n
}\n
", "4205755:sub_402cbb": null, "4205760:cgc_isalnum": "long long cgc_isalnum(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0x10]\n
\n
    v0 = cgc_isalpha(a0);\n
    return v0 | cgc_isdigit(a0);\n
}\n
", "4205803:sub_402ceb": null, "4205808:cgc_isdigit": "long long cgc_isdigit(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (a0 >= 48 && a0 <= 57)\n
    {\n
        v0 = 1;\n
        return v0;\n
    }\n
    v0 = 0;\n
    return v0;\n
}\n
", "4205859:sub_402d23": null, "4205872:cgc_isspace": "long long cgc_isspace(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (a0 != 32 && a0 != 9 && a0 != 10 && a0 != 11 && a0 != 12 && a0 != 13)\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
    v0 = 1;\n
    return v0;\n
}\n
", "4205963:sub_402d8b": null, "4205968:cgc_isnan": "long long cgc_isnan()\n
{\n
    return ((CmpF(0, 0) & 69) >> 2 & 1);\n
}\n
", "4205996:sub_402dac": null, "4206000:cgc_isinf": "double cgc_isinf()\n
{\n
    return 0;\n
}\n
", "4206052:sub_402de4": null, "4206064:cgc_atof": "long long cgc_atof(char *a0)\n
{\n
    unsigned int v0;  // [bp-0x30]\n
    int tmp_45;  // tmp #45\n
    int tmp_47;  // tmp #47\n
    int tmp_46;  // tmp #46\n
    unsigned int v1;  // [bp-0x2c]\n
    unsigned long v2;  // [bp-0x28], Other Possible Types: unsigned long long\n
    void* v3;  // [bp-0x20], Other Possible Types: unsigned long\n
    char *v4;  // [bp-0x18], Other Possible Types: unsigned long\n
    void* v5;  // [bp-0x10], Other Possible Types: unsigned long\n
    int v7;  // xmm0\n
    unsigned long v8;  // rax, Other Possible Types: unsigned long long\n
    int v9;  // xmm0\n
    int v10;  // xmm0\n
\n
    v4 = a0;\n
    if (!v4)\n
    {\n
        v5 = 0;\n
        return v8;\n
    }\n
    v3 = 0;\n
    v7 = 0;\n
    v2 = 4591870180066957722;\n
    for (v1 = 1; cgc_isspace(*(v4)); v4 += 1);\n
    v0 = 0;\n
    while (true)\n
    {\n
        v8 = *(v4);\n
        if (!v8)\n
            break;\n
        v8 = *(v4);\n
        if (v8 == 45)\n
        {\n
            if (!v0)\n
            {\n
                v1 = -1;\n
                v0 += 1;\n
                goto LABEL_402fd9;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                return *(v4);\n
            }\n
        }\n
        v8 = *(v4);\n
        if (v8 == 43)\n
        {\n
            if (!v0)\n
            {\n
                v0 += 1;\n
                goto LABEL_402fd9;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                return *(v4);\n
            }\n
        }\n
        v8 = *(v4);\n
        if (v8 == 46)\n
        {\n
            if (v0 && v0 != 1)\n
            {\n
                v5 = 0;\n
                return *(v4);\n
            }\n
            v0 = 2;\n
            goto LABEL_402fd9;\n
        }\n
        v8 = cgc_isdigit(*(v4));\n
        if (!v8)\n
            break;\n
        if (!v0)\n
        {\n
LABEL_402f49:\n
            v0 = 1;\n
            v7 = (0 CONCAT v3) * (0 CONCAT 0x4024000000000000) + (0 CONCAT *(v4) - 48);\n
            v3 = v7;\n
            goto LABEL_402fd9;\n
        }\n
        else\n
        {\n
            if (v0 == 1)\n
                goto LABEL_402f49;\n
            if (v0 != 2)\n
            {\n
                v5 = 0;\n
                return v8;\n
            }\n
            *(&v7) = *(v4) - 48;\n
            v9 = v7 * (0 CONCAT v2) + (0 CONCAT v3);\n
            v3 = v9;\n
            tmp_45 = DivV(tmp_47, tmp_46);\n
            v7 = tmp_45;\n
            v2 = v7;\n
LABEL_402fd9:\n
            v4 += 1;\n
        }\n
    }\n
    *(&v7) = v1;\n
    xmm0<16> = (xmm0<16> * Conv(64->128, Load(addr=stack_base-32, size=8, endness=Iend_LE)))\n
    v5 = v10;\n
    return v8;\n
}\n
", "4206621:sub_40301d": null, "4206624:cgc_atoi": "long long cgc_atoi(char *a0)\n
{\n
    unsigned int v0;  // [bp-0x28]\n
    unsigned int v1;  // [bp-0x24]\n
    unsigned int v2;  // [bp-0x20]\n
    unsigned int v3;  // [bp-0x1c]\n
    char *v4;  // [bp-0x18], Other Possible Types: unsigned long\n
    unsigned int v5;  // [bp-0xc]\n
\n
    v4 = a0;\n
    if (!v4)\n
    {\n
        v5 = 0;\n
        return v5;\n
    }\n
    v3 = 0;\n
    v2 = 1;\n
    for (v0 = 0; cgc_isspace(*(v4)); v4 += 1);\n
    for (v1 = 0; *(v4); v4 += 1)\n
    {\n
        if (*(v4) == 45)\n
        {\n
            if (!v1)\n
            {\n
                v2 = -1;\n
                v1 += 1;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                return v5;\n
            }\n
        }\n
        else\n
        {\n
            if (*(v4) != 43)\n
            {\n
                if (!cgc_isdigit(*(v4)))\n
                    break;\n
                if (v1 && v1 != 1)\n
                {\n
                    v5 = 0;\n
                    return v5;\n
                }\n
                v1 = 1;\n
                v3 = v3 * 10 + *(v4) - 48;\n
                v0 += 1;\n
                if (v0 == 9)\n
                    break;\n
            }\n
            else if (!v1)\n
            {\n
                v1 += 1;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                return v5;\n
            }\n
        }\n
    }\n
    v5 = v3 * v2;\n
    return v5;\n
}\n
", "4207016:sub_4031a8": null, "4207024:cgc_strncpy": "long long cgc_strncpy(unsigned long a0, unsigned long a1, unsigned long a2)\n
{\n
    char *v0;  // [bp-0x28], Other Possible Types: unsigned long\n
\n
    for (v0 = 0; v0 < a2; v0 += 1)\n
    {\n
        if (!v0[a1])\n
            break;\n
        v0[a0] = v0[a1];\n
    }\n
    v0[a0] = 0;\n
    return a0;\n
}\n
", "4207145:sub_403229": null, "4207152:cgc_strcpy": "long long cgc_strcpy(unsigned long a0, unsigned long a1)\n
{\n
    char *v0;  // [bp-0x20], Other Possible Types: unsigned long\n
\n
    for (v0 = 0; v0[a1]; v0 += 1)\n
    {\n
        v0[a0] = v0[a1];\n
    }\n
    v0[a0] = 0;\n
    return a0;\n
}\n
", "4207255:sub_403297": null, "4207264:cgc_bzero": "long long cgc_bzero(char *a0, unsigned long a1)\n
{\n
    char *v0;  // [bp-0x28]\n
    char *v1;  // [bp-0x20], Other Possible Types: unsigned long\n
\n
    v1 = 0;\n
    v0 = a0;\n
    if (!a0)\n
    {\n
        return a0;\n
    }\n
    else if (!a1)\n
    {\n
        return a0;\n
    }\n
    else\n
    {\n
        v1 = 0;\n
        while (true)\n
        {\n
            if (v1 >= a1)\n
                break;\n
            v0[v1] = 0;\n
            v1 += 1;\n
        }\n
        return v1;\n
    }\n
}\n
", "4207382:sub_403316": null, "4207392:cgc_memcmp": "long long cgc_memcmp(char *a0, char *a1, unsigned long a2)\n
{\n
    char v0;  // [bp-0x39]\n
    char *v1;  // [bp-0x38], Other Possible Types: unsigned long\n
    char *v2;  // [bp-0x30], Other Possible Types: unsigned long\n
    unsigned long v3;  // [bp-0x28]\n
    unsigned int v4;  // [bp-0xc]\n
\n
    v3 = a2;\n
    v2 = a0;\n
    v1 = a1;\n
    if (!v3)\n
    {\n
        v4 = 0;\n
        return v4;\n
    }\n
    while (true)\n
    {\n
        v0 = 0;\n
        if (*(v2))\n
        {\n
            v0 = 0;\n
            if (*(v2) == *(v1))\n
                v0 = v3;\n
        }\n
        if (!(v0 & 1))\n
            break;\n
        v2 += 1;\n
        v1 += 1;\n
        v3 -= 1;\n
    }\n
    v2 -= 1;\n
    v1 -= 1;\n
    v4 = *(v2) - *(v1);\n
    return v4;\n
}\n
", "4207616:cgc_strcmp": "long long cgc_strcmp(char *a0, char *a1)\n
{\n
    char v0;  // [bp-0x19]\n
    char *v1;  // [bp-0x18], Other Possible Types: unsigned long\n
    char *v2;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v2 = a0;\n
    v1 = a1;\n
    while (true)\n
    {\n
        v0 = 0;\n
        if (*(v2))\n
            v0 = *(v2) == *(v1);\n
        if (!(v0 & 1))\n
            break;\n
        v2 += 1;\n
        v1 += 1;\n
    }\n
    return *(v2) - *(v1);\n
}\n
", "4207734:sub_403476": null, "4207744:cgc_strncat": "long long cgc_strncat(char *a0, char *a1, unsigned long a2)\n
{\n
    char v0;  // [bp-0x39]\n
    unsigned long v1;  // [bp-0x38]\n
    unsigned long v2;  // [bp-0x30]\n
    char *v3;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v2 = cgc_strlen(a0);\n
    if (a0 && a1)\n
    {\n
        v1 = 0;\n
        while (true)\n
        {\n
            v0 = 0;\n
            if (v1 < a2)\n
                v0 = a1[v1];\n
            if (!(v0 & 1))\n
                break;\n
            a0[v1 + v2] = a1[v1];\n
            v1 += 1;\n
        }\n
        a0[v1 + v2] = 0;\n
        v3 = a0;\n
        return v3;\n
    }\n
    v3 = a0;\n
    return v3;\n
}\n
", "4207953:sub_403551": null, "4207968:cgc_strlen": "long long cgc_strlen(unsigned long a0)\n
{\n
    char *v0;  // [bp-0x18], Other Possible Types: unsigned long\n
\n
    if (!a0)\n
        return v0;\n
    for (v0 = 0; *((a0 + v0)); v0 += 1);\n
    return v0;\n
}\n
", "4208051:sub_4035b3": null, "4208064:cgc_receive_until": "long long cgc_receive_until(unsigned long a0, unsigned long long a1, unsigned long long a2)\n
{\n
    char v0;  // [bp-0x31]\n
    void* v1;  // [bp-0x30]\n
    char *v2;  // [bp-0x28], Other Possible Types: unsigned long\n
    unsigned long long v4;  // rcx\n
\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    while (true)\n
    {\n
        if (v2 >= a2)\n
            return v2;\n
        *((a0 + v2)) = 0;\n
        if (cgc_receive(a0, a1, a2, v4))\n
        {\n
            v2 = 0;\n
            return v2;\n
        }\n
        if (v0 == a1)\n
            return v2;\n
        *((a0 + v2)) = v0;\n
        v2 += 1;\n
    }\n
}\n
", "4208241:sub_403671": null, "4208256:cgc_strcat": "long long cgc_strcat(char *a0, unsigned long a1)\n
{\n
    char *v0;  // [bp-0x28], Other Possible Types: unsigned long\n
    char *v1;  // [bp-0x20], Other Possible Types: unsigned long\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (a0 && a1)\n
    {\n
        for (v0 = cgc_strlen(a0); v1[a1]; v1 += 1)\n
        {\n
            a0[v0] = v1[a1];\n
            v0 += 1;\n
        }\n
        v1 = v0;\n
        return v1;\n
    }\n
    return v1;\n
}\n
", "4208418:sub_403722": null, "4208432:cgc_itoa": "long long cgc_itoa(unsigned long a0, unsigned long a1, unsigned long a2)\n
{\n
    void* v0;  // [bp-0x38], Other Possible Types: unsigned long\n
    char *v1;  // [bp-0x30], Other Possible Types: unsigned long\n
    char *v2;  // [bp-0x28], Other Possible Types: unsigned long\n
    unsigned long v3;  // [bp-0x18]\n
\n
    v3 = a1;\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v2;\n
    v0 = v3;\n
    do\n
    {\n
        v1 += 1;\n
        v0 = (0 CONCAT v0) /m 10;\n
    } while (v0);\n
    if (v1 >= a2)\n
        return v2;\n
    v2 = v1;\n
    v1 -= 1;\n
    do\n
    {\n
        *((a0 + v1)) = ((0 CONCAT v3) /m 10 >> 64) + 48;\n
        v3 = (0 CONCAT v3) /m 10;\n
        v1 -= 1;\n
    } while (v3);\n
    *((a0 + v2)) = 0;\n
    return v2;\n
}\n
", "4208664:sub_403818": null, "4208672:cgc_puts": "long long cgc_puts(unsigned long a0)\n
{\n
    unsigned long v0;  // [bp-0x20]\n
    unsigned long long v2;  // rsi\n
    unsigned long long v3;  // rdx\n
    unsigned long long v4;  // rcx\n
\n
    v0 = a0;\n
    cgc_strlen(a0);\n
    return cgc_transmit(a0, v2, v3, v4);\n
}\n
", "4208728:sub_403858": null, "4208736:cgc_cityMenu": "typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
extern unsigned int g_410060;\n
\n
long long cgc_cityMenu(unsigned int a0[22], unsigned int a1, unsigned int a2, unsigned long a3, unsigned int a4)\n
{\n
    char v0;  // [bp-0x63]\n
    char v1;  // [bp-0x62]\n
    char v2;  // [bp-0x61]\n
    struct_0 *v3;  // [bp-0x60]\n
    unsigned long v4;  // [bp-0x58]\n
    unsigned long long v5[4];  // [bp-0x50], Other Possible Types: unsigned long\n
    char v6;  // [bp-0x48]\n
    unsigned int v7;  // [bp-0x1c]\n
    unsigned int v8;  // [bp-0xc]\n
    unsigned long v10;  // rax\n
    unsigned long v11;  // xmm0lq\n
\n
    v7 = 0;\n
    v5[0] = 0;\n
    if (!a0)\n
    {\n
        v8 = 0;\n
        return v8;\n
    }\n
    while (true)\n
    {\n
        v2 = 0;\n
        cgc_printf(\"\\n
City: @s\\n
\", a0, a2, a3, a4);\n
        cgc_printf(\"1) Display City Info\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"2) Set Mayor\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"3) Set Url\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"4) Set Population\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"5) Add Border\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"6) Delete City and Exit Menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"7) Exit Menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"Selection: \", a1, a2, a3, a4);\n
        v3 = &v6;\n
        cgc_bzero(&v6, 30);\n
        cgc_receive_until(v3, 10, 4);\n
        v7 = cgc_atoi(v3);\n
        v10 = v7 - 1;\n
        a3 = v10;\n
        v4 = v10;\n
        switch (v10)\n
        {\n
        case 0:\n
            cgc_printCityInfo(a0);\n
            break;\n
        case 1:\n
            cgc_printf(\"\\n
-> \", 10, 4, &g_410060, a4);\n
            cgc_bzero(&v6, 30);\n
            a2 = 29;\n
            cgc_receive_until(&v6, 10, 29);\n
            v7 = 0;\n
            while (true)\n
            {\n
                v1 = 1;\n
                if (!cgc_isalnum((&v6)[v7]))\n
                    v1 = (&v6)[v7] == 32;\n
                if (!(v1 & 1))\n
                    break;\n
                *(20 + &a0[0] + v7) = (&v6)[v7];\n
                v7 += 1;\n
            }\n
            a3 = v7;\n
            *(20 + &a0[0] + a3) = 0;\n
            break;\n
        case 2:\n
            cgc_printf(\"\\n
-> \", 10, 4, &g_410060, a4);\n
            cgc_bzero(&v6, 30);\n
            a2 = 29;\n
            cgc_receive_until(&v6, 10, 29);\n
            v7 = 0;\n
            while (true)\n
            {\n
                v0 = 1;\n
                if (!cgc_isalnum((&v6)[v7]))\n
                {\n
                    v0 = 1;\n
                    if ((&v6)[v7] != 58)\n
                    {\n
                        v0 = 1;\n
                        if ((&v6)[v7] != 46)\n
                            v0 = (&v6)[v7] == 47;\n
                    }\n
                }\n
                if (!(v0 & 1))\n
                    break;\n
                *(50 + &a0[0] + v7) = (&v6)[v7];\n
                v7 += 1;\n
            }\n
            a3 = v7;\n
            *(50 + &a0[0] + a3) = 0;\n
            break;\n
        case 3:\n
            cgc_printf(\"\\n
-> \", 10, 4, &g_410060, a4);\n
            cgc_bzero(&v6, 30);\n
            a2 = 29;\n
            cgc_receive_until(&v6, 10, 29);\n
            a3 = cgc_atoi(&v6);\n
            a0[20] = a3;\n
            break;\n
        case 4:\n
            if (a0[21] > 10)\n
            {\n
                cgc_printf(\"Max Borders\\n
\", 10, 4, &g_410060, a4);\n
                break;\n
            }\n
            else if (!cgc_allocate(a0, 10, 4))\n
            {\n
                cgc_printf(\"Lat Start: \", 10, 4, &g_410060, a4);\n
                cgc_bzero(&v6, 30);\n
                cgc_receive_until(&v6, 10, 19);\n
                cgc_atof(&v6);\n
                v5[0] = v11;\n
                cgc_printf(\"Long Start: \", 10, 19, &g_410060, a4);\n
                cgc_bzero(&v6, 30);\n
                cgc_receive_until(&v6, 10, 19);\n
                cgc_atof(&v6);\n
                v5[1] = v11;\n
                cgc_printf(\"Lat End: \", 10, 19, &g_410060, a4);\n
                cgc_bzero(&v6, 30);\n
                cgc_receive_until(&v6, 10, 19);\n
                cgc_atof(&v6);\n
                v5[2] = v11;\n
                cgc_printf(\"Long End: \", 10, 19, &g_410060, a4);\n
                cgc_bzero(&v6, 30);\n
                cgc_receive_until(&v6, 10, 19);\n
                cgc_atof(&v6);\n
                v5[3] = v11;\n
                a2 = v5;\n
                *(&a0[1 + 2 * a0[21]]) = a2;\n
                a3 = a0[21] + 1;\n
                a0[21] = a3;\n
                break;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                continue;\n
            }\n
        case 5:\n
            cgc_freeCity(a0);\n
            v8 = 0;\n
            return v8;\n
        case 6:\n
            v8 = 1;\n
            return v8;\n
        default:\n
            cgc_printf(\"Invalid\\n
\", 10, 4, v10, a4);\n
        }\n
    }\n
}\n
", "4209922:sub_403d02": null, "4209936:cgc_printCityInfo": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[19];\n
    char field_14;\n
    char padding_15[29];\n
    char field_32;\n
    char padding_33[29];\n
    unsigned int field_50;\n
    unsigned int field_54;\n
} struct_0;\n
\n
long long cgc_printCityInfo(struct_0 *a0, unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    void* v0;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned int v1;  // [bp-0x14]\n
    unsigned long long v3;  // rax\n
    unsigned long v4;  // rcx\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v3;\n
    cgc_printf(\"\\t\\t\\t\\tCity: \", a1, a2, a3, a4);\n
    if (!a0->field_0)\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    else\n
        cgc_printf(\"@s\\n
\", a0, a2, a3, a4);\n
    if (a0->field_50 >= 0)\n
        cgc_printf(\"\\t\\t\\t\\t\\tPopulation: @d\\n
\", a0->field_50, a2, a3, a4);\n
    if (a0->field_14)\n
        cgc_printf(\"\\t\\t\\t\\t\\tMayor: @s\\n
\", &a0->field_14, a2, a3, a4);\n
    if (a0->field_32)\n
        cgc_printf(\"\\t\\t\\t\\t\\tUrl: @s\\n
\", &a0->field_32, a2, a3, a4);\n
    v1 = 0;\n
    while (true)\n
    {\n
        v3 = v1;\n
        if (v3 >= a0->field_54)\n
            break;\n
        v4 = v1;\n
        v0 = *(&(&a0[1].field_0)[8 * v4]);\n
        if (v0)\n
            cgc_printf(\"\\t\\t\\t\\t\\tBorder: @f @f @f @f\\n
\", a1, a2, v4, a4);\n
        v1 += 1;\n
    }\n
    return v1;\n
}\n
", "4210289:sub_403e71": null, "4210304:cgc_freeCity": "typedef struct struct_0 {\n
    char padding_0[84];\n
    unsigned int field_54;\n
} struct_0;\n
\n
long long cgc_freeCity(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rsi\n
    unsigned long long v3;  // rax\n
\n
    v0 = 0;\n
    if (!a0)\n
        return v3;\n
    for (v0 = 0; v0 < a0->field_54; v0 += 1)\n
    {\n
        cgc_deallocate(a0, v2);\n
    }\n
    v3 = cgc_deallocate(a0, v2);\n
    return v3;\n
}\n
", "4210414:sub_403eee": null, "4210416:cgc_freeCharPtr": "long long cgc_freeCharPtr(unsigned int *a0)\n
{\n
    unsigned long v0;  // [bp-0x18]\n
    unsigned long v2;  // rax\n
    unsigned long long v3;  // rsi\n
\n
    if (!a0)\n
    {\n
        return v2;\n
    }\n
    else if (!*(&a0))\n
    {\n
        return a0;\n
    }\n
    else\n
    {\n
        v0 = *(&a0);\n
        cgc_strlen(*(&a0));\n
        cgc_deallocate(a0, v3);\n
        *(&a0) = 0;\n
        return a0;\n
    }\n
}\n
", "4210519:sub_403f57": null, "4210528:cgc_initCity": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[79];\n
    unsigned int field_50;\n
    unsigned int field_54;\n
} struct_0;\n
\n
long long cgc_initCity(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
\n
    v0 = 0;\n
    if (!a0)\n
        return a0;\n
    for (v0 = 0; v0 < 10; v0 += 1)\n
    {\n
        (&a0->field_0)[v0] = 0;\n
        *(&(&a0[1].field_0)[8 * v0]) = 0;\n
    }\n
    for (v0 = 0; v0 < 30; v0 += 1)\n
    {\n
        a0->padding_1[19 + v0] = 0;\n
        a0->padding_1[49 + v0] = 0;\n
    }\n
    a0->field_50 = -1;\n
    a0->field_54 = 0;\n
    return a0;\n
}\n
", "4210700:sub_40400c": null, "4210704:cgc_skipOpen": "long long cgc_skipOpen(unsigned long long a0, unsigned long a1)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (!a0)\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
    else if (cgc_incChar(a0) != -1)\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        if (a1)\n
        {\n
            if (!cgc_atChar(a0, 35))\n
            {\n
                v0 = 0;\n
                return v0;\n
            }\n
            else if (cgc_incChar(a0) == -1)\n
            {\n
                v0 = 0;\n
                return v0;\n
            }\n
        }\n
        v0 = 1;\n
        return v0;\n
    }\n
    else\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
}\n
", "4210921:sub_4040e9": null, "4210928:cgc_cityTopLevel": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
extern char g_41007c;\n
\n
long long cgc_cityTopLevel(struct_0 *a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x70]\n
    unsigned long v1;  // [bp-0x68]\n
    unsigned long v2;  // [bp-0x60]\n
    unsigned int v3;  // [bp-0x58]\n
    unsigned long v4;  // [bp-0x50]\n
    unsigned long v5;  // [bp-0x48]\n
    unsigned long v6;  // [bp-0x40]\n
    unsigned int v7;  // [bp-0x38]\n
    unsigned int v8;  // [bp-0x34]\n
    void* v9;  // [bp-0x30], Other Possible Types: unsigned int, unsigned long\n
    unsigned int v10;  // [bp-0x28]\n
    unsigned int v11;  // [bp-0x24]\n
    void* v12;  // [bp-0x20], Other Possible Types: unsigned long, unsigned int [22]\n
    unsigned int v13;  // [bp-0x14]\n
    unsigned long long v15;  // rax\n
    unsigned int v16[22];  // rax\n
\n
    v13 = 0;\n
    *(&v12[0]) = 0;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    if (!a0)\n
    {\n
        return v12;\n
    }\n
    else if (!cgc_skipOpen(a0, 0))\n
    {\n
        return v12;\n
    }\n
    else\n
    {\n
        cgc_getIndex(a0, &v11);\n
        v10 = cgc_skipAlpha(a0);\n
        if (v10 == -1)\n
        {\n
            return v12;\n
        }\n
        else if (v11 == v10)\n
        {\n
            return v12;\n
        }\n
        else\n
        {\n
            v9 = cgc_copyData(a0, v11, v10);\n
            if (!v9)\n
            {\n
                return v12;\n
            }\n
            else if (cgc_strcmp(v9, \"City\"))\n
            {\n
                v6 = v9;\n
                cgc_strlen(v9);\n
                cgc_deallocate(a0, \"City\");\n
                return v12;\n
            }\n
            else\n
            {\n
                v5 = v9;\n
                cgc_strlen(v9);\n
                cgc_deallocate(a0, \"City\");\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 125))\n
                    return v12;\n
                cgc_incChar(a0);\n
                cgc_skipWhiteSpace(a0);\n
                v13 = a0->field_c;\n
                if (cgc_allocate(a0, 125, a2))\n
                {\n
                    v12 = 0;\n
                }\n
                else\n
                {\n
                    cgc_initCity(v12);\n
                    while (true)\n
                    {\n
                        v9 = cgc_pullNextElementName(a0);\n
                        if (v9)\n
                        {\n
                            v7 = cgc_elementNameToEnum(v9);\n
                            *(&v3) = v9;\n
                            cgc_strlen(*(&v3));\n
                            cgc_deallocate(a0, a1);\n
                            v15 = v7 - 1;\n
                            a3 = v15;\n
                            v4 = v15;\n
                            switch (v15)\n
                            {\n
                            case 0:\n
                                *(&v9) = cgc_extractName(a0);\n
                                if (!v9)\n
                                    break;\n
                                cgc_bzero(v12, 20);\n
                                cgc_strncpy(v12, *(&v9), 19);\n
                                v2 = *(&v9);\n
                                cgc_strlen(*(&v9));\n
                                cgc_deallocate(a0, a1);\n
                                v9 = 0;\n
                                goto LABEL_404491;\n
                            case 9:\n
                                a3 = cgc_extractPopulation(a0);\n
                                v12[20] = a3;\n
                                if (v12[20] < 0)\n
                                    break;\n
                            case 13:\n
                                if (v12[21] >= 10)\n
                                    break;\n
                                v8 = v12[21];\n
                                a2 = cgc_extractBorder(a0);\n
                                *(&v12[1 + 2 * v8]) = a2;\n
                                a3 = v8;\n
                                if (!*(&v12[1 + 2 * a3]))\n
                                    break;\n
                                v16 = v12;\n
                                a3 = v16[21] + 1;\n
                                v16[21] = a3;\n
                                goto LABEL_404491;\n
                            case 22:\n
                                *(&v9) = cgc_extractMayor(a0);\n
                                if (!v9)\n
                                    break;\n
                                cgc_bzero(&v12[5], 30);\n
                                cgc_strcpy(&v12[5], *(&v9));\n
                                cgc_freeCharPtr(&v9);\n
                                goto LABEL_404491;\n
                            case 23:\n
                                *(&v9) = cgc_extractUrl(a0);\n
                                if (!v9)\n
                                    break;\n
                                cgc_bzero(&v12[12] + 2, 30);\n
                                cgc_strncpy(&v12[12] + 2, *(&v9), 29);\n
                                cgc_freeCharPtr(&v9);\n
                                goto LABEL_404491;\n
                            default:\n
                                cgc_printf(\"!!Invalid element ID for City\\n
\", a1, a2, a3, a4);\n
                                break;\n
                            }\n
LABEL_404491:\n
                            v13 = a0->field_c;\n
                        }\n
                        else if (cgc_skipOpen(a0, 1))\n
                        {\n
                            cgc_getIndex(a0, &v11);\n
                            v10 = cgc_skipAlpha(a0);\n
                            if (v10 != -1 && v11 != v10)\n
                            {\n
                                v9 = cgc_copyData(a0, v11, v10);\n
                                if (v9)\n
                                {\n
                                    if (!cgc_strcmp(v9, \"City\"))\n
                                    {\n
                                        v0 = v9;\n
                                        cgc_strlen(v9);\n
                                        cgc_deallocate(a0, \"City\");\n
                                        cgc_skipWhiteSpace(a0);\n
                                        if (cgc_atChar(a0, 125))\n
                                        {\n
                                            cgc_incChar(a0);\n
                                            return v12;\n
                                        }\n
                                        break;\n
                                    }\n
                                    else\n
                                    {\n
                                        v1 = v9;\n
                                        cgc_strlen(v9);\n
                                        cgc_deallocate(a0, \"City\");\n
                                        break;\n
                                    }\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
                if (v12)\n
                {\n
                    cgc_freeCity(v12);\n
                    v12 = 0;\n
                }\n
                cgc_printf(\"!!Error at: @s\\n
\", a0->field_0 + v13, a2, a3, a4);\n
                a0->field_c = v13;\n
                return v12;\n
            }\n
        }\n
    }\n
}\n
", "4212233:sub_404609": null, "4212240:cgc_extractMayor": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractMayor(struct_0 *a0)\n
{\n
    void* v0;  // [bp-0x30], Other Possible Types: unsigned long\n
    unsigned int v1;  // [bp-0x28]\n
    unsigned int v2;  // [bp-0x24]\n
    void* v3;  // [bp-0x20], Other Possible Types: unsigned int, unsigned long\n
    void* v4;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v3 = 0;\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v4 = 0;\n
        return v4;\n
    }\n
    else if (cgc_skipOpen(a0, 0))\n
    {\n
        v2 = a0->field_c;\n
        v1 = cgc_skipAlpha(a0);\n
        if (v1 != -1 && v2 != v1)\n
        {\n
            v3 = cgc_copyData(a0, v2, v1);\n
            if (!v3)\n
            {\n
                v4 = 0;\n
                return v4;\n
            }\n
            else if (!cgc_strcmp(v3, \"Mayor\"))\n
            {\n
                cgc_freeCharPtr(&v3);\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 125))\n
                {\n
                    v4 = 0;\n
                    return v4;\n
                }\n
                cgc_incChar(a0);\n
                v2 = cgc_skipWhiteSpace(a0);\n
                if (v1 >= 0 && v2 != v1)\n
                {\n
                    for (v1 = cgc_skipToNonAlphaNumSpace(a0); cgc_isspace(*((a0->field_0 + v1 - 1))); v1 -= 1);\n
                    *(&v3) = cgc_copyData(a0, v2, v1);\n
                    if (!v3)\n
                    {\n
                        v4 = 0;\n
                        return v4;\n
                    }\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_skipOpen(a0, 1))\n
                    {\n
LABEL_4048b3:\n
                        cgc_freeCharPtr(&v3);\n
                    }\n
                    else\n
                    {\n
                        v2 = a0->field_c;\n
                        v1 = cgc_skipAlpha(a0);\n
                        if (v1 != -1 && v2 != v1)\n
                        {\n
                            v0 = cgc_copyData(a0, v2, v1);\n
                            if (v0)\n
                            {\n
                                if (cgc_strcmp(v0, \"Mayor\"))\n
                                {\n
                                    cgc_freeCharPtr(&v0);\n
                                    goto LABEL_4048b3;\n
                                }\n
                                else\n
                                {\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (cgc_atChar(a0, 125))\n
                                    {\n
                                        cgc_incChar(a0);\n
                                        goto LABEL_4048bc;\n
                                    }\n
                                }\n
                            }\n
                        }\n
                        goto LABEL_4048b3;\n
                    }\n
LABEL_4048bc:\n
                    v4 = *(&v3);\n
                    return v4;\n
                }\n
                v4 = 0;\n
                return v4;\n
            }\n
            else\n
            {\n
                cgc_freeCharPtr(&v3);\n
                v4 = 0;\n
                return v4;\n
            }\n
        }\n
        v4 = 0;\n
        return v4;\n
    }\n
    else\n
    {\n
        v4 = 0;\n
        return v4;\n
    }\n
}\n
", "4212942:sub_4048ce": null, "4212944:cgc_extractUrl": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractUrl(struct_0 *a0)\n
{\n
    void* v0;  // [bp-0x28], Other Possible Types: unsigned long\n
    unsigned int v1;  // [bp-0x1c]\n
    void* v2;  // [bp-0x18], Other Possible Types: unsigned long\n
\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        return v2;\n
    }\n
    else if (!cgc_skipOpen(a0, 0))\n
    {\n
        return v2;\n
    }\n
    else\n
    {\n
        cgc_getIndex(a0, &v1);\n
        cgc_skipAlpha(a0);\n
        v2 = cgc_copyData(a0, v1, a0->field_c);\n
        if (!v2)\n
        {\n
            return v2;\n
        }\n
        else if (!cgc_strcmp(v2, \"Url\"))\n
        {\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
                return v2;\n
            cgc_incChar(a0);\n
            cgc_skipWhiteSpace(a0);\n
            cgc_getIndex(a0, &v1);\n
            cgc_skipUrl(a0);\n
            v2 = cgc_copyData(a0, v1, a0->field_c);\n
            if (!v2)\n
                return v2;\n
            cgc_skipWhiteSpace(a0);\n
            if (cgc_skipOpen(a0, 1))\n
            {\n
                cgc_getIndex(a0, &v1);\n
                cgc_skipAlpha(a0);\n
                v0 = cgc_copyData(a0, v1, a0->field_c);\n
                if (v0)\n
                {\n
                    if (cgc_strcmp(v0, \"Url\"))\n
                    {\n
                        cgc_freeCharPtr(&v0);\n
                    }\n
                    else\n
                    {\n
                        cgc_freeCharPtr(&v0);\n
                        cgc_skipWhiteSpace(a0);\n
                        if (cgc_atChar(a0, 125))\n
                        {\n
                            cgc_incChar(a0);\n
                            return v2;\n
                        }\n
                    }\n
                }\n
            }\n
            if (!v2)\n
                return v2;\n
            cgc_freeCharPtr(&v2);\n
        }\n
        else\n
        {\n
            cgc_freeCharPtr(&v2);\n
            return v2;\n
        }\n
    }\n
}\n
", "4213468:sub_404adc": null, "4213472:cgc_countryMenu": "typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
long long cgc_countryMenu(unsigned int a0[235], unsigned int a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    char v0;  // [bp-0x71]\n
    char *v1;  // [bp-0x70]\n
    unsigned long long v2[4];  // [bp-0x68], Other Possible Types: unsigned long\n
    char *v3;  // [bp-0x60], Other Possible Types: unsigned long\n
    char v4;  // [bp-0x58]\n
    struct_0 *v5;  // [bp-0x28], Other Possible Types: unsigned long\n
    unsigned int v6;  // [bp-0x1c]\n
    unsigned int v7;  // [bp-0xc]\n
    unsigned long v9;  // xmm0lq\n
    unsigned long v10;  // rcx\n
\n
    v6 = 0;\n
    v5 = 0;\n
    v3 = 0;\n
    v2 = 0;\n
    if (!a0)\n
    {\n
        v7 = 0;\n
        return v7;\n
    }\n
    while (true)\n
    {\n
        cgc_printf(\"\\n
Country: @s\\n
\", a0, a2, a3, a4);\n
        cgc_printf(\"1) Display CountryInfo\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"2) Set Capitol\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"3) Set Population\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"4) Add Language\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"5) Add border\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"6) Add Territory\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"7) Select Territory\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"8) Delete Country and Exit Menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"9) Exit menu\\n
\", a1, a2, a3, a4);\n
        cgc_bzero(&v4, 40);\n
        cgc_printf(\"Selection: \", 40, a2, a3, a4);\n
        a2 = 3;\n
        cgc_receive_until(&v4, 10, 3);\n
        v6 = cgc_atoi(&v4);\n
        if (v6 < 1)\n
        {\n
LABEL_404c06:\n
            cgc_printf(\"Invalid...\\n
\", 10, 3, a3, a4);\n
        }\n
        else\n
        {\n
            if (!(v6 <= 9))\n
                goto LABEL_404c06;\n
            if (v6 == 1)\n
            {\n
                cgc_printCountryInfo(a0);\n
                goto LABEL_4052ed;\n
            }\n
            if (v6 == 2)\n
            {\n
                cgc_printf(\"\\n
-> \", 10, 3, a3, a4);\n
                cgc_bzero(&v4, 40);\n
                a2 = 39;\n
                cgc_receive_until(&v4, 10, 39);\n
                for (v6 = 0; cgc_isalpha((&v4)[v6]); v6 += 1)\n
                {\n
                    *(20 + &a0[0] + v6) = (&v4)[v6];\n
                }\n
                a3 = v6;\n
                *(20 + &a0[0] + a3) = 0;\n
                goto LABEL_4052ed;\n
            }\n
            if (v6 == 3)\n
            {\n
                cgc_printf(\"\\n
-> \", 10, 3, a3, a4);\n
                cgc_bzero(&v4, 40);\n
                a2 = 19;\n
                cgc_receive_until(&v4, 10, 19);\n
                a3 = cgc_atoi(&v4);\n
                a0[10] = a3;\n
                goto LABEL_4052ed;\n
            }\n
            if (v6 == 4)\n
            {\n
                if (a0[11] >= 10)\n
                {\n
                    cgc_printf(\"!!Max languages reached\\n
\", 10, 3, a3, a4);\n
                    continue;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"\\n
-> \", 10, 3, a3, a4);\n
                    cgc_bzero(&v4, 40);\n
                    cgc_receive(\"\\n
-> \", 40, 3, a3);\n
                    cgc_strlen(&v4);\n
                    if (!cgc_allocate(\"\\n
-> \", 40, 3))\n
                    {\n
                        v1 = v3;\n
                        cgc_bzero(v1, cgc_strlen(&v4) + 1);\n
                        for (v6 = 0; cgc_isalpha((&v4)[v6]); v6 += 1)\n
                        {\n
                            *((v3 + v6)) = (&v4)[v6];\n
                        }\n
                        *((v3 + v6)) = 0;\n
                        a2 = v3;\n
                        *(&a0[12 + 2 * a0[11]]) = a2;\n
                        a3 = a0[11] + 1;\n
                        a0[11] = a3;\n
                        goto LABEL_4052ed;\n
                    }\n
                    else\n
                    {\n
                        v3 = 0;\n
                        continue;\n
                    }\n
                }\n
            }\n
            if (v6 == 5)\n
            {\n
                if (a0[32] >= 100)\n
                {\n
                    cgc_printf(\"!!Max borders reached\\n
\", 10, 3, a3, a4);\n
                    continue;\n
                }\n
                else if (!cgc_allocate(\"Selection: \", 10, 3))\n
                {\n
                    cgc_printf(\"Lat Start: \", 10, 3, a3, a4);\n
                    cgc_bzero(&v4, 40);\n
                    cgc_receive(\"Lat Start: \", 40, 3, a3);\n
                    cgc_atof(&v4);\n
                    *(v2) = v9;\n
                    cgc_printf(\"Long Start: \", 40, 3, a3, a4);\n
                    cgc_bzero(&v4, 40);\n
                    cgc_receive(\"Long Start: \", 40, 3, a3);\n
                    cgc_atof(&v4);\n
                    *((v2 + 8)) = v9;\n
                    cgc_printf(\"Lat End: \", 40, 3, a3, a4);\n
                    cgc_bzero(&v4, 40);\n
                    cgc_receive(\"Lat End: \", 40, 3, a3);\n
                    cgc_atof(&v4);\n
                    *((v2 + 16)) = v9;\n
                    cgc_printf(\"Long End: \", 40, 3, a3, a4);\n
                    cgc_bzero(&v4, 40);\n
                    cgc_receive(\"Long End: \", 40, 3, a3);\n
                    cgc_atof(&v4);\n
                    *((v2 + 24)) = v9;\n
                    a2 = v2;\n
                    *(&a0[34 + 2 * a0[32]]) = a2;\n
                    a3 = a0[32] + 1;\n
                    a0[32] = a3;\n
                    goto LABEL_4052ed;\n
                }\n
                else\n
                {\n
                    v2[0] = 0;\n
                    continue;\n
                }\n
            }\n
            if (v6 == 6)\n
            {\n
                if (a0[234] >= 10)\n
                {\n
                    cgc_printf(\"!!Max Territories reached\\n
\", 10, 3, a3, a4);\n
                    continue;\n
                }\n
                else\n
                {\n
                    v6 = 0;\n
                    while (true)\n
                    {\n
                        v0 = 0;\n
                        if (v6 < 10)\n
                        {\n
                            a3 = v6;\n
                            v0 = *(&a0[1 + 1 + 2 * a3]);\n
                        }\n
                        if (!(v0 & 1))\n
                            break;\n
                        v6 += 1;\n
                    }\n
                    if (v6 == 10)\n
                    {\n
                        cgc_printf(\"!!Max Territories reached\\n
\", 10, 3, a3, a4);\n
                        continue;\n
                    }\n
                    else if (!cgc_allocate(\"Selection: \", 10, 3))\n
                    {\n
                        v10 = v6;\n
                        cgc_initTerritory(*(&a0[1 + 1 + 2 * v10]));\n
                        cgc_printf(\"\\n
New Territory: \", 10, 3, v10, a4);\n
                        cgc_bzero(&v4, 40);\n
                        a2 = 19;\n
                        cgc_receive_until(&v4, 10, 19);\n
                        for (v5 = 0; cgc_isalnum((&v4)[v5]); v5 += 1)\n
                        {\n
                            *((*(&a0[1 + 1 + 2 * v6]) + v5)) = (&v4)[v5];\n
                        }\n
                        *((*(&a0[1 + 1 + 2 * v6]) + v5)) = 0;\n
                        a3 = a0[234] + 1;\n
                        a0[234] = a3;\n
                        goto LABEL_4052ed;\n
                    }\n
                    else\n
                    {\n
                        cgc_printf(\"!!Failed to allocate structure\\n
\", 10, 3, a3, a4);\n
                        a3 = v6;\n
                        *(&a0[1 + 1 + 2 * a3]) = 0;\n
                        continue;\n
                    }\n
                }\n
            }\n
            if (v6 != 7)\n
            {\n
                if (v6 == 8)\n
                {\n
                    cgc_freeCountry(a0);\n
                    v7 = 0;\n
                    return v7;\n
                }\n
                else if (v6 == 9)\n
                {\n
                    v7 = 1;\n
                    return v7;\n
                }\n
LABEL_4052ed:\n
            }\n
            else\n
            {\n
                cgc_printf(\"\\n
Territories:\\n
\", 10, 3, a3, a4);\n
                for (v6 = 0; v6 < 10; v6 += 1)\n
                {\n
                    if (*(&a0[1 + 1 + 2 * v6]))\n
                    {\n
                        a3 = v6;\n
                        cgc_printf(\"@d) @s\\n
\", v6 + 1, *(&a0[1 + 1 + 2 * a3]), a3, a4);\n
                    }\n
                }\n
                cgc_bzero(&v4, 40);\n
                cgc_printf(\"\\n
-> \", 40, 3, a3, a4);\n
                cgc_receive(\"\\n
-> \", 40, 3, a3);\n
                v6 = cgc_atoi(&v4);\n
                if (v6 >= 1 && v6 <= 10)\n
                {\n
                    a3 = v6 - 1;\n
                    if (*(&a0[1 + 1 + 2 * a3]))\n
                    {\n
                        a3 = v6 - 1;\n
                        if (!cgc_territoryMenu(*(&a0[1 + 1 + 2 * a3])))\n
                        {\n
                            *(&a0[234 + 2 * v6]) = 0;\n
                            a3 = a0[234] - 1;\n
                            a0[234] = a3;\n
                        }\n
                        goto LABEL_4052ed;\n
                    }\n
                }\n
                cgc_printf(\"Invalid choice...\\n
\", 40, 3, a3, a4);\n
            }\n
        }\n
    }\n
}\n
", "4215577:sub_405319": null, "4215584:cgc_printCountryInfo": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[19];\n
    char field_14;\n
    char padding_15[19];\n
    unsigned int field_28;\n
    unsigned int field_2c;\n
    char padding_30[80];\n
    unsigned int field_80;\n
} struct_0;\n
\n
long long cgc_printCountryInfo(struct_0 *a0, unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    void* v0;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned int v1;  // [bp-0x14]\n
    unsigned long v3;  // rcx\n
    unsigned long long v4;  // rax, Other Possible Types: unsigned long\n
    unsigned long v5;  // rcx\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v4;\n
    cgc_printf(\"\\tCountry: \", a1, a2, a3, a4);\n
    if (a0->field_0)\n
        cgc_printf(\"@s\\n
\", a0, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    cgc_printf(\"\\t\\tCapitol: \", a1, a2, a3, a4);\n
    if (a0->field_14)\n
        cgc_printf(\"@s\\n
\", &a0->field_14, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    if (a0->field_28 >= 0)\n
        cgc_printf(\"\\t\\tPopulation: @d\\n
\", a0->field_28, a2, a3, a4);\n
    for (; v1 < a0->field_2c; v1 += 1)\n
    {\n
        if (*(&a0->padding_30[8 * v1]))\n
        {\n
            v3 = v1;\n
            cgc_printf(\"\\t\\tLanguage: @s\\n
\", *(&a0->padding_30[8 * v3]), a2, v3, a4);\n
        }\n
    }\n
    v1 = 0;\n
    while (true)\n
    {\n
        v4 = v1;\n
        if (v4 >= a0->field_80)\n
            break;\n
        v5 = v1;\n
        v0 = *(&a0[1].padding_1[3 + 8 * v5]);\n
        if (v0)\n
            cgc_printf(\"\\t\\tBorder: @f @f @f @f\\n
\", a1, a2, v5, a4);\n
        v1 += 1;\n
    }\n
    for (v1 = 0; v1 < 10; v1 = v4)\n
    {\n
        if (*(&(&a0[7].field_14)[8 * v1]))\n
            cgc_printTerritoryInfo(*(&(&a0[7].field_14)[8 * v1]));\n
        v4 = v1 + 1;\n
    }\n
    return v4;\n
}\n
", "4216089:sub_405519": null, "4216096:cgc_freeCountry": "long long cgc_freeCountry(unsigned int a0[33])\n
{\n
    unsigned long v0;  // [bp-0x20]\n
    unsigned int v1;  // [bp-0x14]\n
    unsigned long long v3;  // rsi\n
    unsigned long long v4;  // rax\n
\n
    if (!a0)\n
        return v4;\n
    for (v1 = 0; v1 < a0[32]; v1 += 1)\n
    {\n
        if (*(&a0[1 + 1 + 2 * v1]))\n
        {\n
            cgc_deallocate(a0, v3);\n
            *(&a0[1 + 1 + 2 * v1]) = 0;\n
        }\n
    }\n
    for (v1 = 0; v1 < a0[11]; v1 += 1)\n
    {\n
        if (*(&a0[12 + 2 * v1]))\n
        {\n
            v0 = *(&a0[12 + 2 * v1]);\n
            cgc_strlen(*(&a0[12 + 2 * v1]));\n
            cgc_deallocate(a0, v3);\n
            *(&a0[12 + 2 * v1]) = 0;\n
        }\n
    }\n
    for (v1 = 0; v1 < 10; v1 += 1)\n
    {\n
        if (*(&a0[7 + 5 + 2 * v1]))\n
        {\n
            cgc_freeTerritory(*(&a0[7 + 5 + 2 * v1]));\n
            *(&a0[7 + 5 + 2 * v1]) = 0;\n
        }\n
    }\n
    v4 = cgc_deallocate(a0, v3);\n
    return v4;\n
}\n
", "4216478:sub_40569e": null, "4216480:cgc_initCountry": "long long cgc_initCountry(unsigned int a0[33])\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rax\n
\n
    v0 = 0;\n
    if (a0)\n
    {\n
        cgc_bzero(a0, 20);\n
        a0[10] = -1;\n
        a0[11] = 0;\n
        a0[32] = 0;\n
        cgc_bzero(&a0[12], 80);\n
        cgc_bzero(&a0[1 + 1], 800);\n
        v2 = cgc_bzero(&a0[7 + 5], 80);\n
        return v2;\n
    }\n
    return v2;\n
}\n
", "4216631:sub_405737": null, "4216640:cgc_countryTopLevel": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
extern unsigned int g_410250;\n
\n
long long cgc_countryTopLevel(struct_0 *a0, unsigned long a1, unsigned long a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x70]\n
    unsigned long v1;  // [bp-0x68]\n
    unsigned long v2;  // [bp-0x60]\n
    unsigned long v3;  // [bp-0x58]\n
    unsigned int v4;  // [bp-0x50]\n
    unsigned long v5;  // [bp-0x48]\n
    unsigned long v6;  // [bp-0x40]\n
    unsigned long v7;  // [bp-0x38]\n
    unsigned int v8;  // [bp-0x30]\n
    unsigned int v9;  // [bp-0x2c]\n
    unsigned int v10;  // [bp-0x28]\n
    unsigned int v11;  // [bp-0x24]\n
    void* v12;  // [bp-0x20], Other Possible Types: unsigned long, unsigned int, unsigned long long\n
    void* v13;  // [bp-0x18], Other Possible Types: unsigned long, unsigned int [235]\n
    unsigned long long v15;  // rax\n
    unsigned int v17[235];  // rax\n
    unsigned int v18[235];  // rax\n
    unsigned int v19[235];  // rax\n
    unsigned long v20;  // rcx\n
\n
    *(&v13[0]) = 0;\n
    v12 = 0;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    if (!a0)\n
    {\n
        return v13;\n
    }\n
    else if (!cgc_allocate(a0, a1, a2))\n
    {\n
        cgc_initCountry(v13);\n
        cgc_skipWhiteSpace(a0);\n
        v11 = cgc_getIndex(a0, &v11);\n
        if (cgc_atChar(a0, 123) && cgc_skipLength(a0, 1) >= 0)\n
        {\n
            cgc_skipWhiteSpace(a0);\n
            v10 = a0->field_c;\n
            v9 = cgc_skipAlpha(a0);\n
            if (v9 == -1)\n
            {\n
LABEL_40583d:\n
            }\n
            else\n
            {\n
                if (v10 == v9)\n
                    goto LABEL_40583d;\n
                v12 = cgc_copyData(a0, v10, v9);\n
                if (v12)\n
                {\n
                    if (cgc_strcmp(v12, \"Country\"))\n
                    {\n
                        cgc_printf(\"!!Country: Invalid opening element id\\n
\", \"Country\", a2, a3, a4);\n
                        v7 = v12;\n
                        cgc_strlen(v12);\n
                        cgc_deallocate(a0, \"Country\");\n
                    }\n
                    else\n
                    {\n
                        v6 = v12;\n
                        cgc_strlen(v12);\n
                        cgc_deallocate(a0, \"Country\");\n
                        cgc_skipWhiteSpace(a0);\n
                        if (*((a0->field_0 + a0->field_c)) == 125)\n
                        {\n
                            cgc_incChar(a0);\n
                            v11 = a0->field_c;\n
                            v12 = cgc_pullNextElementName(a0);\n
                            while (true)\n
                            {\n
                                if (!v12)\n
                                {\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (cgc_atChar(a0, 123) && cgc_skipLength(a0, 1) >= 0)\n
                                    {\n
                                        cgc_skipWhiteSpace(a0);\n
                                        if (cgc_atChar(a0, 35) && cgc_skipLength(a0, 1) >= 0)\n
                                        {\n
                                            v10 = a0->field_c;\n
                                            v9 = cgc_skipAlpha(a0);\n
                                            if (v9 >= 0 && v10 != v9)\n
                                            {\n
                                                v12 = cgc_copyData(a0, v10, v9);\n
                                                if (v12)\n
                                                {\n
                                                    if (cgc_strcmp(v12, \"Country\"))\n
                                                    {\n
                                                        v1 = v12;\n
                                                        cgc_strlen(v12);\n
                                                        cgc_deallocate(a0, \"Country\");\n
                                                        break;\n
                                                    }\n
                                                    else\n
                                                    {\n
                                                        v0 = v12;\n
                                                        cgc_strlen(v12);\n
                                                        cgc_deallocate(a0, \"Country\");\n
                                                        cgc_skipWhiteSpace(a0);\n
                                                        if (cgc_atChar(a0, 125))\n
                                                        {\n
                                                            cgc_incChar(a0);\n
                                                            return v13;\n
                                                        }\n
                                                        break;\n
                                                    }\n
                                                }\n
                                            }\n
                                        }\n
                                    }\n
                                }\n
                                else\n
                                {\n
                                    v8 = cgc_elementNameToEnum(v12);\n
                                    *(&v4) = v12;\n
                                    cgc_strlen(*(&v4));\n
                                    cgc_deallocate(a0, a1);\n
                                    v15 = v8 - 1;\n
                                    v5 = v15;\n
                                    switch (v15)\n
                                    {\n
                                    case 0:\n
                                        *(&v12) = cgc_extractName(a0);\n
                                        if (!v12)\n
                                            break;\n
                                        cgc_bzero(v13, 20);\n
                                        cgc_strncpy(v13, *(&v12), 19);\n
                                        v3 = *(&v12);\n
                                        cgc_strlen(*(&v12));\n
                                        cgc_deallocate(a0, a1);\n
                                        v12 = 0;\n
                                        goto LABEL_405c15;\n
                                    case 9:\n
                                        v13[10] = cgc_extractPopulation(a0);\n
                                        if (v13[10] < 0)\n
                                            break;\n
                                    case 11:\n
                                        *(&v12) = cgc_extractCapitol(a0);\n
                                        if (!v12)\n
                                            break;\n
                                        cgc_bzero(&v13[5], 20);\n
                                        cgc_strncpy(&v13[5], *(&v12), 19);\n
                                        v2 = *(&v12);\n
                                        cgc_strlen(*(&v12));\n
                                        cgc_deallocate(a0, a1);\n
                                        v12 = 0;\n
                                        goto LABEL_405c15;\n
                                    case 12:\n
                                        if (v13[11] >= 10)\n
                                        {\n
                                            cgc_printf(\"!!Max country language count is @d\\n
\", 10, a2, &g_410250, a4);\n
                                            break;\n
                                        }\n
                                        else\n
                                        {\n
                                            a2 = cgc_extractLanguage(a0);\n
                                            *(&v13[12 + 2 * v13[11]]) = a2;\n
                                            if (!*(&v13[12 + 2 * v13[11]]))\n
                                                break;\n
                                            v17 = v13;\n
                                            v17[11] = v17[11] + 1;\n
                                            goto LABEL_405c15;\n
                                        }\n
                                    case 13:\n
                                        if (v13[32] >= 100)\n
                                        {\n
                                            cgc_printf(\"!!Max country border count is @d\\n
\", 100, a2, &g_410250, a4);\n
                                            break;\n
                                        }\n
                                        else\n
                                        {\n
                                            a2 = cgc_extractBorder(a0);\n
                                            *(&v13[34 + 2 * v13[32]]) = a2;\n
                                            if (!*(&v13[34 + 2 * v13[32]]))\n
                                                break;\n
                                            v18 = v13;\n
                                            v18[32] = v18[32] + 1;\n
                                            goto LABEL_405c15;\n
                                        }\n
                                    case 14:\n
                                        if (v13[234] >= 10)\n
                                        {\n
                                            cgc_printf(\"!!Max territories is @d\\n
\", 10, a2, &g_410250, a4);\n
                                            break;\n
                                        }\n
                                        else\n
                                        {\n
                                            a2 = cgc_territoryTopLevel(a0);\n
                                            *(&v13[1 + 1 + 2 * v13[234]]) = a2;\n
                                            if (!*(&v13[1 + 1 + 2 * v13[234]]))\n
                                                break;\n
                                            v19 = v13;\n
                                            v19[234] = v19[234] + 1;\n
                                            goto LABEL_405c15;\n
                                        }\n
                                    default:\n
                                        cgc_printf(\"Invalid for country\\n
\", a1, a2, v15, a4);\n
                                        break;\n
                                    }\n
LABEL_405c15:\n
                                    v11 = a0->field_c;\n
                                    v12 = cgc_pullNextElementName(a0);\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        if (v13)\n
        {\n
            cgc_freeCountry(v13);\n
            v13 = 0;\n
        }\n
        v20 = v11;\n
        a0->field_c = v20;\n
        cgc_printf(\"Error at: @s\\n
\", a0->field_0 + a0->field_c, a2, v20, a4);\n
        return v13;\n
    }\n
    else\n
    {\n
        v13 = 0;\n
        return v13;\n
    }\n
}\n
", "4218351:sub_405def": null, "4218352:cgc_extractCapitol": "long long cgc_extractCapitol(unsigned long long a0, unsigned long long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x48]\n
    unsigned long v1;  // [bp-0x40]\n
    unsigned long v2;  // [bp-0x38]\n
    unsigned int v3;  // [bp-0x30]\n
    unsigned int v4;  // [bp-0x2c]\n
    void* v5;  // [bp-0x28], Other Possible Types: unsigned int, unsigned long\n
    void* v6;  // [bp-0x20], Other Possible Types: char *, unsigned long\n
    void* v7;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v6 = 0;\n
    v5 = 0;\n
    v4 = 0;\n
    v3 = 0;\n
    if (!a0)\n
    {\n
        v7 = 0;\n
        return v7;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v7 = v5;\n
        return v7;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v4 = cgc_skipWhiteSpace(a0);\n
        v3 = cgc_skipToNonAlphaNum(a0);\n
        if (v3 == -1)\n
        {\n
            v7 = 0;\n
            return v7;\n
        }\n
        v6 = cgc_copyData(a0, v4, v3);\n
        if (!v6)\n
        {\n
            v7 = 0;\n
            return v7;\n
        }\n
        else if (!cgc_strcmp(v6, \"Capitol\"))\n
        {\n
            cgc_deallocate(a0, \"Capitol\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v7 = 0;\n
                return v7;\n
            }\n
            else if (cgc_incChar(a0) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v4);\n
                v3 = cgc_skipAlpha(a0);\n
                if (!(v4 ^ v3))\n
                {\n
                    v7 = 0;\n
                    return v7;\n
                }\n
                *(&v5) = cgc_copyData(a0, v4, v3);\n
                if (!*(&v5))\n
                {\n
                    v7 = 0;\n
                    return v7;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else if (cgc_incChar(a0) == -1)\n
                {\n
                    cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                    }\n
                    else\n
                    {\n
                        v4 = cgc_skipLength(a0, 1);\n
                        if (v4 == -1)\n
                        {\n
                            cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        }\n
                        else\n
                        {\n
                            v3 = cgc_skipToNonAlphaNum(a0);\n
                            if (v3 == -1)\n
                            {\n
                                cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                            }\n
                            else\n
                            {\n
                                v6 = cgc_copyData(a0, v4, v3);\n
                                if (cgc_strcmp(v6, \"Capitol\"))\n
                                {\n
                                    cgc_printf(\"!!Invalid closing element id: @s\\n
\", v6, a2, a3, a4);\n
                                    v2 = v6;\n
                                    cgc_strlen(v6);\n
                                    cgc_deallocate(a0, a1);\n
                                }\n
                                else\n
                                {\n
                                    v1 = v6;\n
                                    cgc_strlen(v6);\n
                                    cgc_deallocate(a0, \"Capitol\");\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (!cgc_atChar(a0, 125))\n
                                    {\n
                                        cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                                    }\n
                                    else\n
                                    {\n
                                        cgc_skipLength(a0, 1);\n
                                        goto LABEL_4061e7;\n
                                    }\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
                if (*(&v5))\n
                {\n
                    v0 = *(&v5);\n
                    cgc_strlen(*(&v5));\n
                    cgc_deallocate(a0, a1);\n
                    v5 = 0;\n
                }\n
LABEL_4061e7:\n
                v7 = v5;\n
                return v7;\n
            }\n
            else\n
            {\n
                v7 = 0;\n
                return v7;\n
            }\n
        }\n
        else\n
        {\n
            cgc_deallocate(a0, \"Capitol\");\n
            v6 = 0;\n
            v7 = v6;\n
            return v7;\n
        }\n
    }\n
    else\n
    {\n
        cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v7 = 0;\n
        return v7;\n
    }\n
}\n
", "4219390:sub_4061fe": null, "4219392:cgc_extractLanguage": "long long cgc_extractLanguage(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x58]\n
    unsigned long v1;  // [bp-0x50]\n
    unsigned long v2;  // [bp-0x48]\n
    unsigned long v3;  // [bp-0x40]\n
    unsigned long v4;  // [bp-0x38]\n
    unsigned int v5;  // [bp-0x30]\n
    unsigned int v6;  // [bp-0x2c]\n
    void* v7;  // [bp-0x28], Other Possible Types: unsigned long, unsigned int\n
    void* v8;  // [bp-0x20], Other Possible Types: unsigned long\n
    void* v9;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v9 = 0;\n
        return v9;\n
    }\n
    v6 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v9 = v7;\n
        return v9;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v6 = cgc_skipWhiteSpace(a0);\n
        v5 = cgc_skipToNonAlphaNum(a0);\n
        if (v5 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v9 = v7;\n
            return v9;\n
        }\n
        v8 = cgc_copyData(a0, v6, v5);\n
        if (!v8)\n
        {\n
            cgc_printf(\"!!Copy from @d to @d failed\\n
\", v6, v5, a3, a4);\n
            v9 = 0;\n
            return v9;\n
        }\n
        else if (!cgc_strcmp(v8, \"Language\"))\n
        {\n
            v3 = v8;\n
            cgc_strlen(v8);\n
            cgc_deallocate(a0, \"Language\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v9 = 0;\n
                return v9;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                v6 = cgc_skipWhiteSpace(a0);\n
                v5 = cgc_skipAlpha(a0);\n
                if (v6 == v5)\n
                {\n
                    cgc_printf(\"!!Failed to find language data\\n
\", 1, a2, a3, a4);\n
                    v9 = v7;\n
                    return v9;\n
                }\n
                *(&v7) = cgc_copyData(a0, v6, v5);\n
                if (!*(&v7))\n
                {\n
                    cgc_printf(\"!!Failed to copy language data\\n
\", a1, a2, a3, a4);\n
                    v9 = *(&v7);\n
                    return v9;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else if (cgc_incChar(a0) == -1)\n
                {\n
                    cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                    }\n
                    else\n
                    {\n
                        v6 = cgc_skipLength(a0, 1);\n
                        if (v6 == -1)\n
                        {\n
                            cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        }\n
                        else\n
                        {\n
                            v5 = cgc_skipToNonAlphaNum(a0);\n
                            if (v5 == -1)\n
                            {\n
                                cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                            }\n
                            else\n
                            {\n
                                v8 = cgc_copyData(a0, v6, v5);\n
                                if (cgc_strcmp(v8, \"Language\"))\n
                                {\n
                                    cgc_printf(\"!!Invalid closing element id: @s\\n
\", v8, a2, a3, a4);\n
                                    v2 = v8;\n
                                    cgc_strlen(v8);\n
                                    cgc_deallocate(a0, a1);\n
                                }\n
                                else\n
                                {\n
                                    v1 = v8;\n
                                    cgc_strlen(v8);\n
                                    cgc_deallocate(a0, \"Language\");\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (!cgc_atChar(a0, 125))\n
                                    {\n
                                        cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                                    }\n
                                    else\n
                                    {\n
                                        cgc_skipLength(a0, 1);\n
                                        goto LABEL_406672;\n
                                    }\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
                if (*(&v7))\n
                {\n
                    v0 = *(&v7);\n
                    cgc_strlen(*(&v7));\n
                    cgc_deallocate(a0, a1);\n
                    v7 = 0;\n
                }\n
LABEL_406672:\n
                v9 = v7;\n
                return v9;\n
            }\n
            else\n
            {\n
                cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v9 = v7;\n
                return v9;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Language\\\"\\n
\", \"Language\", a2, a3, a4);\n
            v4 = v8;\n
            cgc_strlen(v8);\n
            cgc_deallocate(a0, \"Language\");\n
            v8 = 0;\n
            v9 = v7;\n
            return v9;\n
        }\n
    }\n
    else\n
    {\n
        cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v9 = v7;\n
        return v9;\n
    }\n
}\n
", "4220553:sub_406689": null, "4220560:cgc_countyMenu": null, "4222219:sub_406d0b": null, "4222224:cgc_printCountyInfo": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[19];\n
    char field_14;\n
    char padding_15[19];\n
    unsigned int field_28;\n
    char padding_2c[4];\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    char padding_40[168];\n
    unsigned int field_e8;\n
} struct_0;\n
\n
long long cgc_printCountyInfo(struct_0 *a0, unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rax, Other Possible Types: unsigned long\n
\n
    v0 = 0;\n
    if (!a0)\n
        return v2;\n
    cgc_printf(\"\\t\\t\\tCounty: \", a1, a2, a3, a4);\n
    if (a0->field_0)\n
        cgc_printf(\"@s\\n
\", a0, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    cgc_printf(\"\\t\\t\\t\\tSeat: \", a1, a2, a3, a4);\n
    if (a0->field_14)\n
        cgc_printf(\"@s\\n
\", &a0->field_14, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    if (a0->field_28 >= 0)\n
        cgc_printf(\"\\t\\t\\t\\tPopulation: @d\\n
\", a0->field_28, a2, a3, a4);\n
    if (!(CmpF(a0->field_30, 0) & 1))\n
        cgc_printf(\"\\t\\t\\t\\tArea: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_38, 0) & 1))\n
        cgc_printf(\"\\t\\t\\t\\tDensity: @f\\n
\", a1, a2, a3, a4);\n
    v0 = 0;\n
    while (true)\n
    {\n
        v2 = v0;\n
        if (v2 >= a0->field_e8)\n
            break;\n
        cgc_printf(\"\\t\\t\\t\\tBorder: @f @f @f @f\\n
\", a1, a2, v0, a4);\n
        v0 += 1;\n
    }\n
    for (v0 = 0; v0 < 20; v0 = v2)\n
    {\n
        if (*(&a0->padding_40[8 + 8 * v0]))\n
            cgc_printCityInfo(*(&a0->padding_40[8 + 8 * v0]), a1, a2, v0, a4);\n
        v2 = v0 + 1;\n
    }\n
    return v2;\n
}\n
", "4222745:sub_406f19": null, "4222752:cgc_freeCounty": "typedef struct struct_0 {\n
    char padding_0[232];\n
    unsigned int field_e8;\n
} struct_0;\n
\n
long long cgc_freeCounty(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rsi\n
    unsigned long long v3;  // rax\n
\n
    v0 = 0;\n
    if (!a0)\n
        return v3;\n
    for (v0 = 0; v0 < a0->field_e8; v0 += 1)\n
    {\n
        if (*(&a0[1].padding_0[4 + 8 * v0]))\n
        {\n
            cgc_deallocate(a0, v2);\n
            *(&a0[1].padding_0[4 + 8 * v0]) = 0;\n
        }\n
    }\n
    for (v0 = 0; v0 < 20; v0 += 1)\n
    {\n
        cgc_freeCity(*(&a0->padding_0[72 + 8 * v0]));\n
        *(&a0->padding_0[72 + 8 * v0]) = 0;\n
    }\n
    v3 = cgc_deallocate(a0, v2);\n
    return v3;\n
}\n
", "4222987:sub_40700b": null, "4222992:cgc_initCounty": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[39];\n
    unsigned int field_28;\n
    char padding_2c[4];\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned int field_40;\n
    char padding_44[164];\n
    unsigned int field_e8;\n
} struct_0;\n
\n
long long cgc_initCounty(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
\n
    v0 = 0;\n
    if (!a0)\n
        return a0;\n
    for (v0 = 0; v0 < 20; v0 += 1)\n
    {\n
        (&a0->field_0)[v0] = 0;\n
        a0->padding_1[19 + v0] = 0;\n
        *(&a0->padding_44[4 + 8 * v0]) = 0;\n
        *(&a0[1].padding_1[3 + 8 * v0]) = 0;\n
    }\n
    a0->field_28 = -1;\n
    a0->field_30 = 0xbff0000000000000;\n
    a0->field_38 = 0xbff0000000000000;\n
    a0->field_40 = 0;\n
    a0->field_e8 = 0;\n
    return a0;\n
}\n
", "4223188:sub_4070d4": null, "4223200:cgc_countyTopLevel": "typedef struct struct_0 {\n
    char padding_0[40];\n
    unsigned int field_28;\n
    char padding_2c[4];\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned int field_40;\n
    char padding_44[164];\n
    unsigned int field_e8;\n
} struct_0;\n
\n
typedef struct struct_1 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_1;\n
\n
extern unsigned int g_41075c;\n
\n
long long cgc_countyTopLevel(struct_1 *a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x70]\n
    unsigned long v1;  // [bp-0x68]\n
    unsigned long v2;  // [bp-0x60]\n
    unsigned long v3;  // [bp-0x58]\n
    unsigned int v4;  // [bp-0x50]\n
    unsigned long v5;  // [bp-0x48]\n
    unsigned int v6;  // [bp-0x3c]\n
    void* v7;  // [bp-0x38], Other Possible Types: unsigned int, char *, unsigned long, unsigned long long\n
    unsigned int v8;  // [bp-0x30]\n
    unsigned int v9;  // [bp-0x2c]\n
    unsigned int v10;  // [bp-0x28]\n
    unsigned int v11;  // [bp-0x24]\n
    void* v12;  // [bp-0x20], Other Possible Types: unsigned long, struct_0 *\n
    struct_0 *v13;  // [bp-0x10], Other Possible Types: unsigned long\n
    unsigned long long v15;  // rax\n
    struct_0 *v20;  // rax\n
    struct_0 *v21;  // rax\n
    int v22;  // xmm0\n
\n
    v12 = 0;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    v7 = 0;\n
    if (!a0)\n
    {\n
        v13 = 0;\n
        return v13;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    v9 = a0->field_c;\n
    if (cgc_atChar(a0, 123))\n
    {\n
        cgc_incChar(a0);\n
        cgc_skipWhiteSpace(a0);\n
        cgc_getIndex(a0, &v11);\n
        v10 = cgc_skipAlpha(a0);\n
        if (v10 != -1 && v11 != v10)\n
        {\n
            v7 = cgc_copyData(a0, v11, v10);\n
            if (v7 && !cgc_strcmp(v7, \"County\"))\n
            {\n
                cgc_deallocate(a0, \"County\");\n
                cgc_skipWhiteSpace(a0);\n
                if (cgc_atChar(a0, 125))\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    cgc_incChar(a0);\n
                    if (cgc_allocate(a0, 125, a2))\n
                    {\n
                        v12 = 0;\n
                    }\n
                    else\n
                    {\n
                        v9 = a0->field_c;\n
                        cgc_initCounty(v12);\n
                        while (true)\n
                        {\n
                            v7 = cgc_pullNextElementName(a0);\n
                            if (!v7)\n
                            {\n
                                cgc_skipWhiteSpace(a0);\n
                                if (cgc_atChar(a0, 123))\n
                                {\n
                                    cgc_skipLength(a0, 1);\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (cgc_atChar(a0, 35))\n
                                    {\n
                                        cgc_skipLength(a0, 1);\n
                                        cgc_getIndex(a0, &v11);\n
                                        cgc_skipAlpha(a0);\n
                                        cgc_getIndex(a0, &v10);\n
                                        if (v11 != v10 && v10 != -1)\n
                                        {\n
                                            v7 = cgc_copyData(a0, v11, v10);\n
                                            if (cgc_strcmp(v7, \"County\"))\n
                                            {\n
                                                v1 = v7;\n
                                                cgc_strlen(v7);\n
                                                cgc_deallocate(a0, \"County\");\n
                                            }\n
                                            else\n
                                            {\n
                                                v0 = v7;\n
                                                cgc_strlen(v7);\n
                                                cgc_deallocate(a0, \"County\");\n
                                                cgc_skipWhiteSpace(a0);\n
                                                if (cgc_atChar(a0, 125))\n
                                                {\n
                                                    cgc_incChar(a0);\n
                                                    break;\n
                                                }\n
                                            }\n
                                        }\n
                                    }\n
                                }\n
LABEL_40768d:\n
                                if (v12)\n
                                {\n
                                    cgc_freeCounty(v12);\n
                                    v12 = 0;\n
                                }\n
                                cgc_printf(\"!!Error at: @s\\n
\", a0->field_0 + v9, a2, a3, a4);\n
                                a0->field_c = v9;\n
                                break;\n
                            }\n
                            else\n
                            {\n
                                v6 = cgc_elementNameToEnum(v7);\n
                                *(&v4) = v7;\n
                                cgc_strlen(*(&v4));\n
                                cgc_deallocate(a0, a1);\n
                                v15 = v6 - 1;\n
                                a3 = v15;\n
                                v5 = v15;\n
                                switch (v15)\n
                                {\n
                                case 0:\n
                                    *(&v7) = cgc_extractName(a0);\n
                                    if (v7)\n
                                    {\n
                                        cgc_bzero(v12, 20);\n
                                        cgc_strncpy(v12, *(&v7), 19);\n
                                        v3 = *(&v7);\n
                                        cgc_strlen(*(&v7));\n
                                        cgc_deallocate(a0, a1);\n
                                        v7 = 0;\n
                                        break;\n
                                    }\n
                                case 9:\n
                                    a3 = cgc_extractPopulation(a0);\n
                                    v12->field_28 = a3;\n
                                    if (!(v12->field_28 < 0))\n
                                        break;\n
                                    goto LABEL_40768d;\n
                                case 13:\n
                                    v8 = v12->field_e8;\n
                                    if (v8 < 20)\n
                                    {\n
                                        a2 = cgc_extractBorder(a0);\n
                                        *(&v12[1].padding_0[4 + 8 * v8]) = a2;\n
                                        a3 = v8;\n
                                        if (*(&v12[1].padding_0[4 + 8 * a3]))\n
                                        {\n
                                            v20 = v12;\n
                                            a3 = v20->field_e8 + 1;\n
                                            v20->field_e8 = a3;\n
                                            break;\n
                                        }\n
                                    }\n
                                case 18:\n
                                    *(&v7) = cgc_extractSeat(a0);\n
                                    if (v7)\n
                                    {\n
                                        cgc_bzero(&v12->padding_0[20], 20);\n
                                        cgc_strncpy(&v12->padding_0[20], *(&v7), 19);\n
                                        v2 = *(&v7);\n
                                        cgc_strlen(*(&v7));\n
                                        cgc_deallocate(a0, a1);\n
                                        v7 = 0;\n
                                        break;\n
                                    }\n
                                case 19:\n
                                    cgc_extractArea(a0);\n
                                    v12->field_30 = v22;\n
                                    v22 = 0;\n
                                    if (((CmpF(0, v12->field_30) & 69 | (CmpF(0, v12->field_30) & 69) >> 6) & 1) == 1)\n
                                        break;\n
                                    goto LABEL_40768d;\n
                                case 20:\n
                                    cgc_extractDensity(a0);\n
                                    v12->field_38 = v22;\n
                                    v22 = 0;\n
                                    if (((CmpF(0, v12->field_38) & 69 | (CmpF(0, v12->field_38) & 69) >> 6) & 1) == 1)\n
                                        break;\n
                                    goto LABEL_40768d;\n
                                case 21:\n
                                    v8 = v12->field_40;\n
                                    if (!(v8 < 20))\n
                                        goto LABEL_40768d;\n
                                    a2 = cgc_cityTopLevel(a0, a1, a2, &g_41075c, a4);\n
                                    *(&v12->padding_44[4 + 8 * v8]) = a2;\n
                                    a3 = v8;\n
                                    if (!*(&v12->padding_44[4 + 8 * a3]))\n
                                        goto LABEL_40768d;\n
                                    v21 = v12;\n
                                    a3 = v21->field_40 + 1;\n
                                    v21->field_40 = a3;\n
                                    cgc_getIndex(a0, &v9);\n
                                default:\n
                                    cgc_printf(\"!!Element not allowed\\n
\", a1, a2, a3, a4);\n
                                    goto LABEL_40768d;\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
    }\n
    v13 = v12;\n
    return v13;\n
}\n
", "4224737:sub_4076e1": null, "4224752:cgc_extractSeat": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractSeat(struct_0 *a0)\n
{\n
    unsigned long v0;  // [bp-0x58]\n
    unsigned long v1;  // [bp-0x50]\n
    unsigned long v2;  // [bp-0x48]\n
    unsigned long v3;  // [bp-0x40]\n
    unsigned long v4;  // [bp-0x38]\n
    unsigned int v5;  // [bp-0x2c]\n
    void* v6;  // [bp-0x28], Other Possible Types: unsigned long\n
    unsigned int v7;  // [bp-0x20]\n
    unsigned int v8;  // [bp-0x1c]\n
    void* v9;  // [bp-0x18], Other Possible Types: unsigned long\n
    unsigned long long v11;  // rsi\n
\n
    v9 = 0;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
        return v9;\n
    cgc_skipWhiteSpace(a0);\n
    cgc_getIndex(a0, &v5);\n
    if (*((a0->field_0 + a0->field_c)) != 123)\n
        return v9;\n
    cgc_incChar(a0);\n
    cgc_skipWhiteSpace(a0);\n
    cgc_getIndex(a0, &v8);\n
    v7 = cgc_skipAlpha(a0);\n
    if (!(v7 != -1 && v8 != v7))\n
        return v9;\n
    v6 = cgc_copyData(a0, v8, v7);\n
    if (!v6)\n
    {\n
        return v9;\n
    }\n
    else if (!cgc_strcmp(v6, \"Seat\"))\n
    {\n
        v3 = v6;\n
        cgc_strlen(v6);\n
        cgc_deallocate(a0, \"Seat\");\n
        cgc_skipWhiteSpace(a0);\n
        if (*((a0->field_0 + a0->field_c)) != 125)\n
            return v9;\n
        cgc_incChar(a0);\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipAlpha(a0);\n
        if (v8 == v7)\n
        {\n
            return v9;\n
        }\n
        else if (v7 == -1)\n
        {\n
            return v9;\n
        }\n
        else\n
        {\n
            v9 = cgc_copyData(a0, v8, v7);\n
            if (!v9)\n
                return v9;\n
            cgc_skipWhiteSpace(a0);\n
            if (cgc_atChar(a0, 123))\n
            {\n
                cgc_incChar(a0);\n
                cgc_skipWhiteSpace(a0);\n
                if (cgc_atChar(a0, 35))\n
                {\n
                    v8 = cgc_incChar(a0);\n
                    v7 = cgc_skipAlpha(a0);\n
                    if (v8 != v7 && v7 != -1)\n
                    {\n
                        v6 = cgc_copyData(a0, v8, v7);\n
                        if (v6)\n
                        {\n
                            if (cgc_strcmp(v6, \"Seat\"))\n
                            {\n
                                v2 = v6;\n
                                cgc_strlen(v6);\n
                                cgc_deallocate(a0, \"Seat\");\n
                            }\n
                            else\n
                            {\n
                                v1 = v6;\n
                                cgc_strlen(v6);\n
                                cgc_deallocate(a0, \"Seat\");\n
                                cgc_skipWhiteSpace(a0);\n
                                if (cgc_atChar(a0, 125))\n
                                {\n
                                    cgc_incChar(a0);\n
                                    return v9;\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
            if (v9)\n
            {\n
                v0 = v9;\n
                cgc_strlen(v9);\n
                cgc_deallocate(a0, v11);\n
                v9 = 0;\n
            }\n
            a0->field_c = v5;\n
            return v9;\n
        }\n
    }\n
    else\n
    {\n
        v4 = v6;\n
        cgc_strlen(v6);\n
        cgc_deallocate(a0, \"Seat\");\n
        return v9;\n
    }\n
}\n
", "4225608:sub_407a48": null, "4225616:cgc_extractDensity": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractDensity(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x2c]\n
    struct_0 *v1;  // [bp-0x28], Other Possible Types: void*\n
    unsigned int v2;  // [bp-0x20]\n
    unsigned int v3;  // [bp-0x1c]\n
    unsigned long long v4;  // [bp-0x18]\n
    struct_0 *v6;  // rax, Other Possible Types: unsigned long\n
    unsigned long long v7;  // rsi\n
\n
    v3 = 0;\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v6;\n
    cgc_getIndex(a0, &v0);\n
    if (cgc_checkId(a0, \"Density\", 0))\n
    {\n
        v3 = cgc_skipWhiteSpace(a0);\n
        v2 = cgc_skipFloat(a0);\n
        v6 = v3;\n
        if (v6 == v2)\n
        {\n
            return v3;\n
        }\n
        else if (v2 == -1)\n
        {\n
            return v3;\n
        }\n
        else\n
        {\n
            v6 = cgc_copyData(a0, v3, v2);\n
            v1 = v6;\n
            if (!v1)\n
                return v6;\n
            cgc_atof(v1);\n
            v4 = 0xbff0000000000000;\n
            cgc_deallocate(a0, v7);\n
            v1 = 0;\n
            v6 = cgc_checkId(a0, \"Density\", 1);\n
            if (v6)\n
                return v6;\n
        }\n
    }\n
    a0->field_c = v0;\n
    v4 = 0xbff0000000000000;\n
    return a0;\n
}\n
", "4225939:sub_407b93": null, "4225952:cgc_extractArea": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractArea(struct_0 *a0)\n
{\n
    struct_0 *v0;  // [bp-0x50]\n
    struct_0 *v1;  // [bp-0x48]\n
    struct_0 *v2;  // [bp-0x40]\n
    struct_0 *v3;  // [bp-0x38]\n
    unsigned int v4;  // [bp-0x2c]\n
    struct_0 *v5;  // [bp-0x28]\n
    unsigned int v6;  // [bp-0x20]\n
    unsigned int v7;  // [bp-0x1c]\n
    unsigned long long v8;  // [bp-0x18]\n
    struct_0 *v9;  // [bp-0x10]\n
    struct_0 *v11;  // rax, Other Possible Types: unsigned long, unsigned long long\n
    unsigned long long v12;  // rsi\n
\n
    v9 = a0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    v4 = 0;\n
    if (!a0)\n
        return v11;\n
    cgc_skipWhiteSpace(a0);\n
    cgc_getIndex(a0, &v4);\n
    v11 = *((v9->field_0 + a0->field_c));\n
    if (v11 != 123)\n
        return *((v9->field_0 + a0->field_c));\n
    cgc_incChar(a0);\n
    cgc_skipWhiteSpace(a0);\n
    cgc_getIndex(a0, &v7);\n
    v11 = cgc_skipAlpha(a0);\n
    v6 = v11;\n
    if (v6 == -1)\n
        return v11;\n
    v11 = v7;\n
    if (v11 != v6)\n
    {\n
        v11 = cgc_copyData(a0, v7, v6);\n
        v5 = v11;\n
        if (!v5)\n
        {\n
            return v11;\n
        }\n
        else if (!cgc_strcmp(v5, \"Area\"))\n
        {\n
            v2 = v5;\n
            cgc_strlen(v5);\n
            cgc_deallocate(a0, \"Area\");\n
            cgc_skipWhiteSpace(a0);\n
            v11 = *((v9->field_0 + a0->field_c));\n
            if (v11 != 125)\n
                return *((v9->field_0 + a0->field_c));\n
            cgc_incChar(a0);\n
            v7 = cgc_skipWhiteSpace(a0);\n
            v6 = cgc_skipFloat(a0);\n
            v11 = v7;\n
            if (v11 == v6)\n
            {\n
                return v7;\n
            }\n
            else if (v6 == -1)\n
            {\n
                return v7;\n
            }\n
            else\n
            {\n
                v11 = cgc_copyData(a0, v7, v6);\n
                v5 = v11;\n
                if (!v5)\n
                    return v11;\n
                cgc_atof(v5);\n
                v8 = 0xbff0000000000000;\n
                cgc_deallocate(a0, v12);\n
                v5 = 0;\n
                cgc_skipWhiteSpace(a0);\n
                if (cgc_atChar(a0, 123))\n
                {\n
                    cgc_incChar(a0);\n
                    cgc_skipWhiteSpace(a0);\n
                    if (cgc_atChar(a0, 35))\n
                    {\n
                        v7 = cgc_incChar(a0);\n
                        v6 = cgc_skipAlpha(a0);\n
                        v5 = cgc_copyData(a0, v7, v6);\n
                        if (v5)\n
                        {\n
                            if (cgc_strcmp(v5, \"Area\"))\n
                            {\n
                                v1 = v5;\n
                                cgc_strlen(v5);\n
                                cgc_deallocate(a0, \"Area\");\n
                            }\n
                            else\n
                            {\n
                                v0 = v5;\n
                                cgc_strlen(v5);\n
                                cgc_deallocate(a0, \"Area\");\n
                                cgc_skipWhiteSpace(a0);\n
                                if (cgc_atChar(a0, 125))\n
                                {\n
                                    v11 = cgc_incChar(a0);\n
                                    return v11;\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
                a0->field_c = v4;\n
                v8 = 0xbff0000000000000;\n
                return a0;\n
            }\n
        }\n
        else\n
        {\n
            v3 = v5;\n
            cgc_strlen(v5);\n
            v11 = cgc_deallocate(a0, \"Area\");\n
            return v11;\n
        }\n
    }\n
}\n
", "4226786:sub_407ee2": null, "4226800:cgc_checkId": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_checkId(struct_0 *a0, char *a1, unsigned long a2)\n
{\n
    unsigned long v0;  // [bp-0x40]\n
    unsigned long v1;  // [bp-0x38]\n
    void* v2;  // [bp-0x30], Other Possible Types: unsigned long\n
    unsigned int v3;  // [bp-0x28]\n
    unsigned int v4;  // [bp-0x24]\n
    unsigned int v5;  // [bp-0x20]\n
\n
    v5 = 0;\n
    v4 = 0;\n
    v3 = 0;\n
    v2 = 0;\n
    if (!a0)\n
        return v5;\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
        return v5;\n
    cgc_incChar(a0);\n
    if (a2 == 1)\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        if (!cgc_atChar(a0, 35))\n
            return v5;\n
        cgc_incChar(a0);\n
    }\n
    v4 = cgc_skipWhiteSpace(a0);\n
    v3 = cgc_skipAlpha(a0);\n
    if (v3 == -1)\n
    {\n
        return v5;\n
    }\n
    else if (v4 == v3)\n
    {\n
        return v5;\n
    }\n
    else\n
    {\n
        v2 = cgc_copyData(a0, v4, v3);\n
        if (!v2)\n
        {\n
            return v5;\n
        }\n
        else if (!cgc_strcmp(v2, a1))\n
        {\n
            v0 = v2;\n
            cgc_strlen(v2);\n
            cgc_deallocate(a0, a1);\n
            cgc_skipWhiteSpace(a0);\n
            if (*((a0->field_0 + a0->field_c)) == 125)\n
            {\n
                cgc_incChar(a0);\n
                v5 = 1;\n
                return v5;\n
            }\n
            return v5;\n
        }\n
        else\n
        {\n
            v1 = v2;\n
            cgc_strlen(v2);\n
            cgc_deallocate(a0, a1);\n
            return v5;\n
        }\n
    }\n
}\n
", "4227222:sub_408096": null, "4227232:cgc_extractBorder": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractBorder(struct_0 *a0, unsigned long a1, unsigned long a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x50]\n
    unsigned long v1;  // [bp-0x48]\n
    unsigned long v2;  // [bp-0x40]\n
    unsigned long v3;  // [bp-0x38]\n
    unsigned int v4;  // [bp-0x30]\n
    unsigned int v5;  // [bp-0x2c]\n
    unsigned long long v6[4];  // [bp-0x28], Other Possible Types: unsigned long\n
    char *v7;  // [bp-0x20], Other Possible Types: void*, unsigned long\n
    unsigned long long v8[4];  // [bp-0x10], Other Possible Types: unsigned long\n
    unsigned long v10;  // xmm0lq\n
\n
    v7 = 0;\n
    v6[0] = 0;\n
    v5 = 0;\n
    v4 = 0;\n
    if (!a0)\n
    {\n
        v8[0] = v6;\n
        return v8;\n
    }\n
    else if (!cgc_allocate(a0, a1, a2))\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        if (!cgc_atChar(a0, 123))\n
        {\n
            cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
            goto LABEL_408743;\n
        }\n
        if (cgc_skipLength(a0, 1) == -1)\n
        {\n
            cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
            goto LABEL_408743;\n
        }\n
        cgc_skipWhiteSpace(a0);\n
        v5 = a0->field_c;\n
        v4 = cgc_skipAlpha(a0);\n
        if (v4 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            goto LABEL_408743;\n
        }\n
        if (v5 == v4)\n
        {\n
LABEL_408743:\n
            cgc_deallocate(a0, a1);\n
            v6 = 0;\n
        }\n
        else\n
        {\n
            v7 = cgc_copyData(a0, v5, v4);\n
            if (!v7)\n
            {\n
                cgc_printf(\"!!Copy from @d to @d failed\\n
\", v5, v4, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            if (cgc_strcmp(v7, \"Border\"))\n
            {\n
                cgc_printf(\"!!Element id is not \\\"Border\\\"\\n
\", \"Border\", a2, a3, a4);\n
                v3 = v7;\n
                cgc_strlen(v7);\n
                cgc_deallocate(a0, \"Border\");\n
                v7 = 0;\n
                goto LABEL_408743;\n
            }\n
            v2 = v7;\n
            cgc_strlen(v7);\n
            cgc_deallocate(a0, \"Border\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            if (cgc_skipLength(a0, 1) == -1)\n
            {\n
                cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            v5 = cgc_skipWhiteSpace(a0);\n
            v4 = cgc_skipFloat(a0);\n
            if (v5 == v4)\n
            {\n
                cgc_printf(\"!!Failed to locate first lat\\n
\", 1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            if (v4 == -1)\n
            {\n
                cgc_printf(\"!!Failed to locate the end of the first latitude float\\n
\", 1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            v7 = cgc_copyData(a0, v5, v4);\n
            if (!v7)\n
            {\n
                cgc_printf(\"!!Failed to copy first latitude float\\n
\", a1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            cgc_atof(v7);\n
            v6[0] = v10;\n
            cgc_deallocate(a0, a1);\n
            v5 = cgc_skipWhiteSpace(a0);\n
            v4 = cgc_skipFloat(a0);\n
            if (v5 == v4)\n
            {\n
                cgc_printf(\"!!Failed to locate first long\\n
\", a1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            if (v5 != -1 && v4 != -1)\n
            {\n
                v7 = cgc_copyData(a0, v5, v4);\n
                if (!v7)\n
                {\n
                    cgc_printf(\"!!Failed to copy first longitude float\\n
\", a1, a2, a3, a4);\n
                    goto LABEL_408743;\n
                }\n
                cgc_atof(v7);\n
                v6[1] = v10;\n
                cgc_deallocate(a0, a1);\n
                v5 = cgc_skipWhiteSpace(a0);\n
                v4 = cgc_skipFloat(a0);\n
                if (v5 == v4)\n
                {\n
                    cgc_printf(\"!!Failed to locate second lat\\n
\", a1, a2, a3, a4);\n
                    goto LABEL_408743;\n
                }\n
                if (v5 != -1 && v4 != -1)\n
                {\n
                    v7 = cgc_copyData(a0, v5, v4);\n
                    if (!v7)\n
                    {\n
                        cgc_printf(\"!!Failed to copy second latitude float\\n
\", a1, a2, a3, a4);\n
                        goto LABEL_408743;\n
                    }\n
                    cgc_atof(v7);\n
                    v6[2] = v10;\n
                    cgc_deallocate(a0, a1);\n
                    v5 = cgc_skipWhiteSpace(a0);\n
                    v4 = cgc_skipFloat(a0);\n
                    if (v5 == v4)\n
                    {\n
                        cgc_printf(\"!!Failed to locate second long\\n
\", a1, a2, a3, a4);\n
                        goto LABEL_408743;\n
                    }\n
                    if (v5 != -1 && v4 != -1)\n
                    {\n
                        v7 = cgc_copyData(a0, v5, v4);\n
                        if (!v7)\n
                        {\n
                            cgc_printf(\"!!Failed to copy second longitude float\\n
\", a1, a2, a3, a4);\n
                            goto LABEL_408743;\n
                        }\n
                        else\n
                        {\n
                            cgc_atof(v7);\n
                            v6[3] = v10;\n
                            cgc_deallocate(a0, a1);\n
                            cgc_skipWhiteSpace(a0);\n
                            if (!cgc_atChar(a0, 123))\n
                            {\n
                                cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                                goto LABEL_408743;\n
                            }\n
                            else if (cgc_skipLength(a0, 1) == -1)\n
                            {\n
                                cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                                goto LABEL_408743;\n
                            }\n
                            else\n
                            {\n
                                cgc_skipWhiteSpace(a0);\n
                                if (!cgc_atChar(a0, 35))\n
                                {\n
                                    cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                                    goto LABEL_408743;\n
                                }\n
                                else\n
                                {\n
                                    v5 = cgc_skipLength(a0, 1);\n
                                    if (v5 == -1)\n
                                    {\n
                                        cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                                        goto LABEL_408743;\n
                                    }\n
                                    else\n
                                    {\n
                                        v4 = cgc_skipAlpha(a0);\n
                                        if (v4 == -1)\n
                                        {\n
                                            cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                                            goto LABEL_408743;\n
                                        }\n
                                        else\n
                                        {\n
                                            v7 = cgc_copyData(a0, v5, v4);\n
                                            if (cgc_strcmp(v7, \"Border\"))\n
                                            {\n
                                                cgc_printf(\"!!Invalid closing element id: @s\\n
\", v7, a2, a3, a4);\n
                                                v1 = v7;\n
                                                cgc_strlen(v7);\n
                                                cgc_deallocate(a0, a1);\n
                                                goto LABEL_408743;\n
                                            }\n
                                            else\n
                                            {\n
                                                v0 = v7;\n
                                                cgc_strlen(v7);\n
                                                cgc_deallocate(a0, \"Border\");\n
                                                cgc_skipWhiteSpace(a0);\n
                                                if (!cgc_atChar(a0, 125))\n
                                                {\n
                                                    cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                                                    goto LABEL_408743;\n
                                                }\n
                                                else\n
                                                {\n
                                                    cgc_skipLength(a0, 1);\n
                                                    goto LABEL_408759;\n
                                                }\n
                                            }\n
                                        }\n
                                    }\n
                                }\n
                            }\n
                        }\n
                    }\n
                    cgc_printf(\"!!Failed to locate second longitude float\\n
\", a1, a2, a3, a4);\n
                    goto LABEL_408743;\n
                }\n
                cgc_printf(\"!!Failed to locate second latitude float\\n
\", a1, a2, a3, a4);\n
                goto LABEL_408743;\n
            }\n
            cgc_printf(\"!!Failed to locate first longitude float\\n
\", a1, a2, a3, a4);\n
            goto LABEL_408743;\n
        }\n
LABEL_408759:\n
        v8 = v6;\n
        return v8;\n
    }\n
    else\n
    {\n
        v6[0] = 0;\n
        v8 = v6;\n
        return v8;\n
    }\n
}\n
", "4228971:sub_40876b": null, "4228976:cgc_extractPopulation": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractPopulation(struct_0 *a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x34]\n
    unsigned int v6;  // [bp-0x30]\n
    unsigned int v7;  // [bp-0x2c]\n
    unsigned int v8;  // [bp-0x28]\n
    unsigned int v9;  // [bp-0x24]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned int v11;  // [bp-0xc]\n
\n
    v10 = 0;\n
    v9 = -1;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = -1;\n
        return v11;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = -1;\n
        return v11;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        v8 = a0->field_c;\n
        v7 = cgc_skipAlpha(a0);\n
        if (v7 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = -1;\n
            return v11;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = -1;\n
            return v11;\n
        }\n
        else if (!cgc_strcmp(v10, \"Population\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Population\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = -1;\n
                return v11;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                v6 = a0->field_c;\n
                v5 = cgc_skipInt(a0);\n
                if (v5 == -1)\n
                {\n
                    cgc_printf(\"!!Failed to locate the end of the population data\\n
\", 1, a2, a3, a4);\n
                    v11 = v7;\n
                    return v11;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = -1;\n
                    return v11;\n
                }\n
                else if (cgc_skipLength(a0, 1) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = -1;\n
                        return v11;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v8;\n
                        return v11;\n
                    }\n
                    v7 = cgc_skipAlpha(a0);\n
                    if (v7 == -1)\n
                    {\n
                        cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = v7;\n
                        return v11;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Population\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        cgc_deallocate(a0, a1);\n
                        v11 = -1;\n
                        return v11;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Population\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = -1;\n
                        return v11;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        cgc_printf(\"!!Failed to copy population data\\n
\", a1, a2, a3, a4);\n
                        v11 = -1;\n
                        return v11;\n
                    }\n
                    v9 = cgc_atoi(v10);\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v11;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                    v11 = -1;\n
                    return v11;\n
                }\n
            }\n
            else\n
            {\n
                cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = -1;\n
                return v11;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Population\\\"\\n
\", \"Population\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Population\");\n
            v10 = 0;\n
            v11 = -1;\n
            return v11;\n
        }\n
    }\n
    else\n
    {\n
        cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = -1;\n
        return v11;\n
    }\n
}\n
", "4230180:sub_408c24": null, "4230192:cgc_extractName": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractName(struct_0 *a0, unsigned long long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x58]\n
    unsigned long v1;  // [bp-0x50]\n
    unsigned long v2;  // [bp-0x48]\n
    unsigned long v3;  // [bp-0x40]\n
    unsigned int v4;  // [bp-0x38]\n
    unsigned int v5;  // [bp-0x34]\n
    unsigned int v6;  // [bp-0x30]\n
    unsigned int v7;  // [bp-0x2c]\n
    void* v8;  // [bp-0x28], Other Possible Types: unsigned long\n
    void* v9;  // [bp-0x20], Other Possible Types: unsigned long\n
    void* v10;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v9 = 0;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    v4 = 0;\n
    if (!a0)\n
    {\n
        v10 = v8;\n
        return v10;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v10 = v8;\n
        return v10;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        v7 = a0->field_c;\n
        v6 = cgc_skipAlpha(a0);\n
        if (v6 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v10 = 0;\n
            return v10;\n
        }\n
        v9 = cgc_copyData(a0, v7, v6);\n
        if (!v9)\n
        {\n
            cgc_printf(\"!!Copy from @d to @d failed\\n
\", v7, v6, a3, a4);\n
            v10 = 0;\n
            return v10;\n
        }\n
        else if (!cgc_strcmp(v9, \"Name\"))\n
        {\n
            v2 = v9;\n
            cgc_strlen(v9);\n
            cgc_deallocate(a0, \"Name\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v10 = 0;\n
                return v10;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                v5 = a0->field_c;\n
                v4 = cgc_skipToNonAlphaNum(a0);\n
                if (v4 == -1)\n
                {\n
                    cgc_printf(\"!!Failed to locate the end of the name data\\n
\", 1, a2, a3, a4);\n
                    v10 = 0;\n
                    return v10;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v10 = 0;\n
                    return v10;\n
                }\n
                else if (cgc_skipLength(a0, 1) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v10 = 0;\n
                        return v10;\n
                    }\n
                    v7 = cgc_skipLength(a0, 1);\n
                    if (v7 == -1)\n
                    {\n
                        cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v10 = 0;\n
                        return v10;\n
                    }\n
                    v6 = cgc_skipAlpha(a0);\n
                    if (v6 == -1)\n
                    {\n
                        cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v10 = 0;\n
                        return v10;\n
                    }\n
                    v9 = cgc_copyData(a0, v7, v6);\n
                    if (cgc_strcmp(v9, \"Name\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v9, a2, a3, a4);\n
                        v1 = v9;\n
                        cgc_strlen(v9);\n
                        cgc_deallocate(a0, a1);\n
                        v10 = 0;\n
                        return v10;\n
                    }\n
                    v0 = v9;\n
                    cgc_strlen(v9);\n
                    cgc_deallocate(a0, \"Name\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v10 = 0;\n
                        return v10;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v8 = cgc_copyData(a0, v5, v4);\n
                    v10 = v8;\n
                    return v10;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                    v10 = 0;\n
                    return v10;\n
                }\n
            }\n
            else\n
            {\n
                cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v10 = 0;\n
                return v10;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Name\\\"\\n
\", \"Name\", a2, a3, a4);\n
            v3 = v9;\n
            cgc_strlen(v9);\n
            cgc_deallocate(a0, \"Name\");\n
            v9 = 0;\n
            v10 = 0;\n
            return v10;\n
        }\n
    }\n
    else\n
    {\n
        cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v10 = v8;\n
        return v10;\n
    }\n
}\n
", "4231337:sub_4090a9": null, "4231344:cgc_pullNextElementName": "long long cgc_pullNextElementName(unsigned int a0[4], unsigned long a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned int v0;  // [bp-0x2c]\n
    unsigned int v1;  // [bp-0x28]\n
    unsigned int v2;  // [bp-0x24]\n
    void* v3;  // [bp-0x20], Other Possible Types: unsigned long\n
    void* v4;  // [bp-0x10], Other Possible Types: unsigned long\n
    char *v6;  // rcx\n
    char *v7;  // rcx\n
    char *v8;  // rcx\n
\n
    v3 = 0;\n
    v2 = 0;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v4 = 0;\n
        return v4;\n
    }\n
    v2 = a0[3];\n
    cgc_skipWhiteSpace(a0);\n
    v6 = a0[3];\n
    if (v6[*(&a0[0])] != 123)\n
    {\n
        cgc_printf(\"!!Invalid opening element: @s\\n
\", *(&a0[0]), a2, v6, a4);\n
    }\n
    else if (cgc_incChar(a0) != -1)\n
    {\n
        cgc_skipWhiteSpace(a0);\n
        for (v1 = a0[3]; v1 < a0[2]; v1 += 1)\n
        {\n
            v7 = v1;\n
            if (!v7[*(&a0[0])])\n
            {\n
                cgc_printf(\"!!Null character hit. Improperly formatted element\\n
\", a1, a2, v7, a4);\n
                break;\n
            }\n
            if (*((*(&a0[0]) + v1)) == 125)\n
            {\n
LABEL_4091d4:\n
                v0 = v1 - a0[3];\n
                if (cgc_allocate(a0, a1, a2, v7))\n
                {\n
                    v3 = 0;\n
                    break;\n
                }\n
                else\n
                {\n
                    cgc_bzero(v3, v0 + 1);\n
                    cgc_strncpy(v3, *(&a0[0]) + a0[3], v0);\n
                    a0[3] = v1;\n
                    cgc_skipWhiteSpace(a0);\n
                    v8 = a0[3];\n
                    if (v8[*(&a0[0])] != 125)\n
                    {\n
                        cgc_printf(\"!!Improperly formatted element name\\n
\", a1, a2, v8, a4);\n
                        cgc_deallocate(\"!!Improperly formatted element name\\n
\", a1);\n
                        v3 = 0;\n
                    }\n
                    break;\n
                }\n
            }\n
            else\n
            {\n
                if (!(!cgc_isspace(*((*(&a0[0]) + v1)))))\n
                    goto LABEL_4091d4;\n
                if (!cgc_isalpha(*((*(&a0[0]) + v1))))\n
                    break;\n
            }\n
        }\n
    }\n
    a0[3] = v2;\n
    v4 = v3;\n
    return v4;\n
}\n
", "4231917:sub_4092ed": null, "4231920:cgc_elementNameToEnum": "long long cgc_elementNameToEnum(unsigned long a0, unsigned long a1, unsigned int a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned int v0;  // [bp-0x20]\n
    unsigned int v1;  // [bp-0x18]\n
    unsigned int v2;  // [bp-0x14]\n
\n
    v2 = 25;\n
    v1 = 0;\n
    if (!a0)\n
        return v2;\n
    v1 = cgc_strlen(a0);\n
    *(&v0) = v1 - 3;\n
    switch (*(&v0))\n
    {\n
    case 0:\n
        if (!cgc_strcmp(a0, \"Url\"))\n
            v2 = 24;\n
        break;\n
    case 1:\n
        if (!cgc_strcmp(a0, \"Name\"))\n
        {\n
            v2 = 1;\n
        }\n
        else if (!cgc_strcmp(a0, \"Mass\"))\n
        {\n
            v2 = 8;\n
        }\n
        else if (!cgc_strcmp(a0, \"Area\"))\n
        {\n
            v2 = 20;\n
        }\n
        else if (!cgc_strcmp(a0, \"Seat\"))\n
        {\n
            v2 = 19;\n
        }\n
        else if (!cgc_strcmp(a0, \"City\"))\n
        {\n
            v2 = 22;\n
        }\n
        break;\n
    case 2:\n
        if (!cgc_strcmp(a0, \"Mayor\"))\n
            v2 = 23;\n
        break;\n
    case 3:\n
        if (!cgc_strcmp(a0, \"Planet\"))\n
        {\n
            v2 = 0;\n
        }\n
        else if (!cgc_strcmp(a0, \"Period\"))\n
        {\n
            v2 = 2;\n
        }\n
        else if (!cgc_strcmp(a0, \"Radius\"))\n
        {\n
            v2 = 6;\n
        }\n
        else if (!cgc_strcmp(a0, \"Border\"))\n
        {\n
            v2 = 14;\n
        }\n
        else if (!cgc_strcmp(a0, \"County\"))\n
        {\n
            v2 = 18;\n
        }\n
        break;\n
    case 4:\n
        if (!cgc_strcmp(a0, \"ERadius\"))\n
        {\n
            v2 = 7;\n
        }\n
        else if (!cgc_strcmp(a0, \"Gravity\"))\n
        {\n
            v2 = 9;\n
        }\n
        else if (!cgc_strcmp(a0, \"Country\"))\n
        {\n
            v2 = 11;\n
        }\n
        else if (!cgc_strcmp(a0, \"Capitol\"))\n
        {\n
            v2 = 12;\n
        }\n
        else if (!cgc_strcmp(a0, \"Founder\"))\n
        {\n
            v2 = 17;\n
        }\n
        else if (!cgc_strcmp(a0, \"Density\"))\n
        {\n
            v2 = 21;\n
        }\n
        break;\n
    case 5:\n
        if (!cgc_strcmp(a0, \"Aphelion\"))\n
        {\n
            v2 = 4;\n
        }\n
        else if (!cgc_strcmp(a0, \"Language\"))\n
        {\n
            v2 = 13;\n
        }\n
        break;\n
    case 6:\n
        if (!cgc_strcmp(a0, \"Territory\"))\n
            v2 = 15;\n
        break;\n
    case 7:\n
        if (!cgc_strcmp(a0, \"OrbitSpeed\"))\n
        {\n
            v2 = 3;\n
        }\n
        else if (!cgc_strcmp(a0, \"Perihelion\"))\n
        {\n
            v2 = 5;\n
        }\n
        else if (!cgc_strcmp(a0, \"Population\"))\n
        {\n
            v2 = 10;\n
        }\n
        break;\n
    case 8:\n
        if (!cgc_strcmp(a0, \"Established\"))\n
            v2 = 16;\n
        break;\n
    default:\n
        v2 = 25;\n
        break;\n
    }\n
    if (v2 != 25)\n
        return v2;\n
    cgc_printf(\"!!Unknown element id: @s\\n
\", a0, a2, *(&v0), a4);\n
}\n
", "4233069:sub_40976d": null, "4233072:cgc_planetMenu": "typedef struct struct_1 {\n
    char field_0;\n
} struct_1;\n
\n
typedef struct struct_0 {\n
    char padding_0[24];\n
    unsigned long long field_18;\n
    unsigned long long field_20;\n
    unsigned long long field_28;\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned long long field_40;\n
    unsigned long long field_48;\n
    unsigned long long field_50;\n
    unsigned int field_58;\n
    unsigned int field_5c;\n
} struct_0;\n
\n
extern unsigned int g_410ce8;\n
\n
long long cgc_planetMenu(struct_0 *a0, unsigned int a1, unsigned long long a2, unsigned long a3, unsigned int a4)\n
{\n
    char v0;  // [bp-0x69]\n
    struct_1 *v1;  // [bp-0x68]\n
    unsigned long v2;  // [bp-0x60]\n
    struct_1 *v3;  // [bp-0x58]\n
    struct_1 *v4;  // [bp-0x50], Other Possible Types: unsigned long\n
    char v5;  // [bp-0x48]\n
    unsigned int v6;  // [bp-0x1c]\n
    unsigned int v7;  // [bp-0xc]\n
    unsigned long v9;  // rax\n
    unsigned long v10;  // xmm0lq\n
    struct_0 *v11;  // rax\n
    struct_0 *v12;  // rax\n
\n
    v6 = 0;\n
    v4 = 0;\n
    v3 = 0;\n
    if (!a0)\n
    {\n
        v7 = 0;\n
        return v7;\n
    }\n
    while (true)\n
    {\n
        v1 = &v5;\n
        cgc_bzero(&v5, 30);\n
        v0 = 0;\n
        cgc_printf(\"\\n
Planet: @s\\n
\", a0, a2, a3, a4);\n
        cgc_printf(\"1) Display planet information\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"2) Set Period\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"3) Set Orbit Speed\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"4) Set Aphelion\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"5) Set Perihelion\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"6) Set Mean Radius\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"7) Set Equatorial Radius\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"8) Set Mass\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"9) Set Gravity\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"10) Set population\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"11) Add Country\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"12) Select country\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"13) Delete Planet and exit menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"14) Exit menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"Selection: \", a1, a2, a3, a4);\n
        cgc_receive_until(v1, 10, 3);\n
        v6 = cgc_atoi(v1);\n
        v9 = v6 - 1;\n
        a3 = v9;\n
        v2 = v9;\n
        switch (v9)\n
        {\n
        case 0:\n
            cgc_printPlanetInfo(a0);\n
            break;\n
        case 1:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_18 = v10;\n
            break;\n
        case 2:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_20 = v10;\n
            break;\n
        case 3:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_28 = v10;\n
            break;\n
        case 4:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_30 = v10;\n
            break;\n
        case 5:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_38 = v10;\n
            break;\n
        case 6:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_40 = v10;\n
            break;\n
        case 7:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_48 = v10;\n
            break;\n
        case 8:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            cgc_atof(&v5);\n
            a0->field_50 = v10;\n
            break;\n
        case 9:\n
            cgc_printf(\"\\n
-> \", 10, 3, &g_410ce8, a4);\n
            a2 = 10;\n
            cgc_receive_until(&v5, 10, 10);\n
            a0->field_58 = cgc_atoi(&v5);\n
            break;\n
        case 10:\n
            if (a0->field_5c >= 30)\n
            {\n
                cgc_printf(\"Too many countries\\n
\", 10, 3, &g_410ce8, a4);\n
                continue;\n
            }\n
            else\n
            {\n
                cgc_printf(\"\\n
New Name: \", 10, 3, &g_410ce8, a4);\n
                a2 = 19;\n
                cgc_receive_until(&v5, 10, 19);\n
                for (v6 = 0; v6 < 30; v6 += 1)\n
                {\n
                    a3 = v6;\n
                    if (!*(&a0[1].padding_0[8 * a3]))\n
                        break;\n
                }\n
                if (v6 == 30)\n
                {\n
                    cgc_printf(\"!!No country slots\\n
\", 10, 19, a3, a4);\n
                    continue;\n
                }\n
                else if (!cgc_allocate(\"\\n
New Name: \", 10, 19))\n
                {\n
                    cgc_initCountry(v3);\n
                    *(&a0[1].padding_0[8 * v6]) = v3;\n
                    for (v4 = 0; cgc_isalnum((&v5)[v4]); v4 += 1)\n
                    {\n
                        v3[v4].field_0 = (&v5)[v4];\n
                    }\n
                    v3[v4].field_0 = 0;\n
                    v11 = a0;\n
                    v11->field_5c = v11->field_5c + 1;\n
                    break;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"!!Failed to allocate structure\\n
\", 10, 19, a3, a4);\n
                    continue;\n
                }\n
            }\n
        case 11:\n
            cgc_printf(\"\\n
Countries:\\n
\", 10, 3, &g_410ce8, a4);\n
            for (v6 = 0; v6 < a0->field_5c; v6 += 1)\n
            {\n
                if (*(&a0[1].padding_0[8 * v6]))\n
                {\n
                    a3 = v6;\n
                    cgc_printf(\"@d) @s\\n
\", v6 + 1, *(&a0[1].padding_0[8 * a3]), a3, a4);\n
                }\n
            }\n
            cgc_bzero(&v5, 30);\n
            cgc_printf(\"\\n
-> \", 30, a2, a3, a4);\n
            a2 = 3;\n
            cgc_receive_until(&v5, 10, 3);\n
            v6 = cgc_atoi(&v5);\n
            if (v6 >= 1 && v6 <= 30)\n
            {\n
                a3 = v6 - 1;\n
                if (*(&a0[1].padding_0[8 * a3]))\n
                {\n
                    a3 = v6 - 1;\n
                    if (!cgc_countryMenu(*(&a0[1].padding_0[8 * a3]), 10, 3, a3, a4))\n
                    {\n
                        *(&(&a0->field_58)[2 * v6]) = 0;\n
                        v12 = a0;\n
                        v12->field_5c = v12->field_5c - 1;\n
                    }\n
                    break;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"Invalid choice...\\n
\", 10, 3, a3, a4);\n
                    continue;\n
                }\n
            }\n
            cgc_printf(\"Invalid choice...\\n
\", 10, 3, a3, a4);\n
            continue;\n
        case 12:\n
            cgc_freePlanet(a0);\n
            v7 = 0;\n
            return v7;\n
        case 13:\n
            v7 = 1;\n
            return v7;\n
        default:\n
            cgc_printf(\"Invalid...\\n
\", 10, 3, v9, a4);\n
            continue;\n
        }\n
    }\n
}\n
", "4234696:sub_409dc8": null, "4234704:cgc_printPlanetInfo": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[23];\n
    unsigned long long field_18;\n
    unsigned long long field_20;\n
    unsigned long long field_28;\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned long long field_40;\n
    unsigned long long field_48;\n
    unsigned long long field_50;\n
    unsigned int field_58;\n
} struct_0;\n
\n
long long cgc_printPlanetInfo(struct_0 *a0, unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    struct_0 *v2;  // rax, Other Possible Types: unsigned long long, unsigned long\n
\n
    v0 = 0;\n
    if (!a0)\n
        return v2;\n
    if (a0->field_0)\n
        cgc_printf(\"Name: @s\\n
\", a0, a2, a3, a4);\n
    else\n
        cgc_printf(\"Name: Unknown\\n
\", a1, a2, a3, a4);\n
    if (a0->field_58 >= 0)\n
        cgc_printf(\"\\tPopulation: @d\\n
\", a0->field_58, a2, a3, a4);\n
    if (!(CmpF(a0->field_18, 0) & 1))\n
        cgc_printf(\"\\tPeriod: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_20, 0) & 1))\n
        cgc_printf(\"\\tOrbit Speed: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_28, 0) & 1))\n
        cgc_printf(\"\\tAphelion: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_30, 0) & 1))\n
        cgc_printf(\"\\tPerihelion: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_38, 0) & 1))\n
        cgc_printf(\"\\tRadius: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_40, 0) & 1))\n
        cgc_printf(\"\\tERadius: @f\\n
\", a1, a2, a3, a4);\n
    if (!(CmpF(a0->field_48, 0) & 1))\n
        cgc_printf(\"\\tMass: @f\\n
\", a1, a2, a3, a4);\n
    v2 = a0;\n
    if (!(CmpF(a0->field_50, 0) & 1))\n
        v2 = cgc_printf(\"\\tGravity: @f\\n
\", a1, a2, a3, a4);\n
    for (; v0 < 30; v0 = v2)\n
    {\n
        if (*(&a0[1].padding_1[3 + 8 * v0]))\n
            cgc_printCountryInfo(*(&a0[1].padding_1[3 + 8 * v0]), a1, a2, v0, a4);\n
        v2 = v0 + 1;\n
    }\n
    return v2;\n
}\n
", "4235265:sub_40a001": null, "4235280:cgc_freePlanet": "long long cgc_freePlanet(unsigned long long a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rsi\n
    unsigned long long v3;  // rax\n
\n
    if (!a0)\n
        return v3;\n
    for (v0 = 0; v0 < 30; v0 += 1)\n
    {\n
        if (*((a0 + (v0 << 3) + 96)))\n
        {\n
            cgc_freeCountry(*((a0 + v0 * 8 + 96)));\n
            *((a0 + v0 * 8 + 96)) = 0;\n
        }\n
    }\n
    v3 = cgc_deallocate(a0, v2);\n
    return v3;\n
}\n
", "4235419:sub_40a09b": null, "4235424:cgc_initPlanet": "typedef struct struct_0 {\n
    char padding_0[24];\n
    unsigned long long field_18;\n
    unsigned long long field_20;\n
    unsigned long long field_28;\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned long long field_40;\n
    unsigned long long field_48;\n
    unsigned long long field_50;\n
    unsigned int field_58;\n
    unsigned int field_5c;\n
} struct_0;\n
\n
long long cgc_initPlanet(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    struct_0 *v2;  // rax, Other Possible Types: unsigned long long, unsigned long\n
\n
    v0 = 0;\n
    if (!a0)\n
        return v2;\n
    cgc_bzero(a0, 20);\n
    a0->field_18 = 0xbff0000000000000;\n
    a0->field_20 = 0xbff0000000000000;\n
    a0->field_28 = 0xbff0000000000000;\n
    a0->field_30 = 0xbff0000000000000;\n
    a0->field_38 = 0xbff0000000000000;\n
    a0->field_40 = 0xbff0000000000000;\n
    a0->field_48 = 0xbff0000000000000;\n
    a0->field_50 = 0xbff0000000000000;\n
    a0->field_58 = -1;\n
    v2 = a0;\n
    for (a0->field_5c = 0; v0 < 30; v0 = v2)\n
    {\n
        *(&a0[1].padding_0[8 * v0]) = 0;\n
        v2 = v0 + 1;\n
    }\n
    return v2;\n
}\n
", "4235683:sub_40a1a3": null, "4235696:cgc_planetTopLevel": "typedef struct struct_0 {\n
    char padding_0[24];\n
    unsigned long long field_18;\n
    unsigned long long field_20;\n
    unsigned long long field_28;\n
    unsigned long long field_30;\n
    unsigned long long field_38;\n
    unsigned long long field_40;\n
    unsigned long long field_48;\n
    unsigned long long field_50;\n
    unsigned int field_58;\n
    unsigned int field_5c;\n
} struct_0;\n
\n
typedef struct struct_1 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_1;\n
\n
extern unsigned int g_410d20;\n
\n
long long cgc_planetTopLevel(struct_1 *a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned int v1;  // [bp-0x58]\n
    unsigned int v2;  // [bp-0x50]\n
    unsigned int v3;  // [bp-0x44]\n
    char *v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x34]\n
    void* v6;  // [bp-0x30], Other Possible Types: unsigned int, unsigned long, char *\n
    unsigned int v7;  // [bp-0x24]\n
    void* v8;  // [bp-0x20], Other Possible Types: struct_0 *, unsigned long\n
    unsigned int v9;  // [bp-0x18]\n
    unsigned int v10;  // [bp-0x14]\n
    unsigned long v12;  // rcx\n
    int v17;  // xmm0\n
    struct_0 *v30;  // rax\n
    unsigned long v31;  // rcx\n
\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
        return v8;\n
    cgc_skipWhiteSpace(a0);\n
    v5 = a0->field_c;\n
    if (a0->field_8 < 9)\n
        return v8;\n
    v4 = \"{Planet}\";\n
    for (v3 = 0; v3 < 8; v3 += 1)\n
    {\n
        a2 = v3;\n
        if (*((a0->field_0 + a0->field_c + v3)) != v4[a2])\n
            return v8;\n
    }\n
    v12 = a0->field_c + 8;\n
    a0->field_c = v12;\n
    cgc_skipWhiteSpace(a0);\n
    if (cgc_allocate(a0, a1, a2))\n
        return v8;\n
    cgc_initPlanet(v8);\n
    *(&v6) = cgc_pullNextElementName(a0, a1, a2, v12, a4);\n
    cgc_getIndex(a0, &v5);\n
    while (true)\n
    {\n
        if (!*(&v6))\n
        {\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 123))\n
            {\n
                cgc_printf(\"!!Closing value failed for Planet\\n
\", 123, a2, v12, a4);\n
            }\n
            else if (cgc_incChar(a0) >= 0)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 35))\n
                {\n
                    cgc_printf(\"!!Malformed closing element\\n
\", 35, a2, v12, a4);\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_getIndex(a0, &v9);\n
                    v10 = cgc_skipAlpha(a0);\n
                    if (v10 == -1)\n
                    {\n
                        v10 = 0;\n
                    }\n
                    else if (v9 != v10)\n
                    {\n
                        v6 = cgc_copyData(a0, v9, v10);\n
                        if (v6)\n
                        {\n
                            if (cgc_strcmp(v6, \"Planet\"))\n
                            {\n
                                cgc_printf(\"!!Closing element malformed\\n
\", \"Planet\", a2, v12, a4);\n
                                cgc_deallocate(\"!!Closing element malformed\\n
\", \"Planet\");\n
                            }\n
                            else\n
                            {\n
                                cgc_deallocate(a0, \"Planet\");\n
                                cgc_skipWhiteSpace(a0);\n
                                if (cgc_atChar(a0, 125))\n
                                {\n
                                    cgc_incChar(a0);\n
                                    return v8;\n
                                }\n
                                cgc_printf(\"!!Failed to find final closing brace\\n
\", 125, a2, v12, a4);\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
            v31 = v5;\n
            a0->field_c = v31;\n
            cgc_printf(\"!!Error at: @s\\n
\", a0->field_0 + a0->field_c, a2, v31, a4);\n
            if (v8)\n
            {\n
                cgc_freePlanet(v8);\n
                v8 = 0;\n
                break;\n
            }\n
        }\n
        else\n
        {\n
            v7 = cgc_elementNameToEnum(*(&v6), a1, a2, v12, a4);\n
            *(&v1) = *(&v6);\n
            cgc_strlen(*(&v1));\n
            cgc_deallocate(a0, a1);\n
            *(&v2) = v7 - 1;\n
            switch (*(&v2))\n
            {\n
            case 0:\n
                *(&v6) = cgc_extractName(a0, a1, a2, 4263200, a4);\n
                if (v6)\n
                {\n
                    cgc_bzero(v8, 20);\n
                    cgc_strncpy(v8, *(&v6), 19);\n
                    v0 = *(&v6);\n
                    cgc_strlen(*(&v6));\n
                    cgc_deallocate(a0, a1);\n
                    v6 = 0;\n
                    goto LABEL_40a5b9;\n
                }\n
            case 1:\n
                cgc_extractPeriod(a0);\n
                v8->field_18 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_18) & 69 | (CmpF(0, v8->field_18) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 2:\n
                cgc_extractOrbitSpeed(a0);\n
                v8->field_20 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_20) & 69 | (CmpF(0, v8->field_20) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 3:\n
                cgc_extractAphelion(a0);\n
                v8->field_28 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_28) & 69 | (CmpF(0, v8->field_28) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 4:\n
                cgc_extractPerihelion(a0);\n
                v8->field_30 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_30) & 69 | (CmpF(0, v8->field_30) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 5:\n
                cgc_extractRadius(a0);\n
                v8->field_38 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_38) & 69 | (CmpF(0, v8->field_38) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 6:\n
                cgc_extractERadius(a0);\n
                v8->field_40 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_40) & 69 | (CmpF(0, v8->field_40) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 7:\n
                cgc_extractMass(a0);\n
                v8->field_48 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_48) & 69 | (CmpF(0, v8->field_48) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 8:\n
                cgc_extractGravity(a0);\n
                v8->field_50 = v17;\n
                v17 = 0;\n
                if (((CmpF(0, v8->field_50) & 69 | (CmpF(0, v8->field_50) & 69) >> 6) & 1) == 1)\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 9:\n
                v12 = cgc_extractPopulation(a0, a1, a2, 4263200, a4);\n
                v8->field_58 = v12;\n
                if (!(v8->field_58 < 0))\n
                    goto LABEL_40a5b9;\n
                break;\n
            case 10:\n
                if (v8->field_5c >= 30)\n
                {\n
                    cgc_printf(\"!!Only @d countries allowed\\n
\", 30, a2, &g_410d20, a4);\n
                    break;\n
                }\n
                a2 = cgc_countryTopLevel(a0, a1, a2, 4263200, a4);\n
                *(&v8[1].padding_0[8 * v8->field_5c]) = a2;\n
                if (!*(&v8[1].padding_0[8 * v8->field_5c]))\n
                    break;\n
                v30 = v8;\n
                v12 = v30->field_5c + 1;\n
                v30->field_5c = v12;\n
LABEL_40a5b9:\n
                cgc_getIndex(a0, &v5);\n
                v6 = cgc_pullNextElementName(a0, a1, a2, v12, a4);\n
                continue;\n
            default:\n
                cgc_printf(\"Not allowed under Planet\\n
\", v6, a2, *(&v2), a4);\n
                break;\n
            }\n
        }\n
    }\n
    return v8;\n
}\n
", "4237243:sub_40a7bb": null, "4237248:cgc_extractPeriod": "long long cgc_extractPeriod(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = v9;\n
        return v13;\n
    }\n
    cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Period\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Period\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the period data\\n
\", 1, a2, a3, a4);\n
                    v11 = v7;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_skipLength(a0, 1) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Period\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Period\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy period data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Period\\\"\\n
\", \"Period\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Period\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4238537:sub_40acc9": null, "4238544:cgc_extractOrbitSpeed": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_extractOrbitSpeed(struct_0 *a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x80]\n
    char *v1;  // [bp-0x78]\n
    unsigned long v2;  // [bp-0x70]\n
    char *v3;  // [bp-0x68]\n
    unsigned long v4;  // [bp-0x60]\n
    char *v5;  // [bp-0x58]\n
    unsigned long v6;  // [bp-0x50]\n
    char *v7;  // [bp-0x48]\n
    unsigned long v8;  // [bp-0x40]\n
    unsigned int v9;  // [bp-0x38]\n
    unsigned int v10;  // [bp-0x34]\n
    unsigned int v11;  // [bp-0x30]\n
    unsigned int v12;  // [bp-0x2c]\n
    unsigned long long v13;  // [bp-0x28], Other Possible Types: unsigned long\n
    void* v14;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v15;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long long v18;  // rax, Other Possible Types: unsigned long\n
    unsigned long v19;  // rax\n
\n
    v14 = 0;\n
    v13 = 0xbff0000000000000;\n
    v12 = 0;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    if (a0)\n
    {\n
        v12 = cgc_skipWhiteSpace(a0);\n
        if (!(cgc_atChar(a0, 123) & 1))\n
        {\n
            v18 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
            goto LABEL_40b1ed;\n
        }\n
        if (cgc_skipLength(a0, 1) == -1)\n
        {\n
            v18 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
            v15 = v13;\n
            return v18;\n
        }\n
        v12 = cgc_skipWhiteSpace(a0);\n
        v11 = cgc_skipToNonAlphaNum(a0);\n
        if (v11 == -1)\n
        {\n
            v18 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
        }\n
        else\n
        {\n
            v14 = cgc_copyData(a0, v12, v11);\n
            if (!v14)\n
            {\n
                v18 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v12, v11, a3, a4);\n
                v15 = 0xbff0000000000000;\n
                return v18;\n
            }\n
            if (cgc_strcmp(v14, \"OrbitSpeed\"))\n
            {\n
                cgc_printf(\"!!Element id is not \\\"OrbitSpeed\\\"\\n
\", \"OrbitSpeed\", a2, a3, a4);\n
                v7 = v14;\n
                v19 = cgc_strlen(v14);\n
                cgc_bzero(v7, v19);\n
                v8 = v14;\n
                cgc_strlen(v14);\n
                v18 = cgc_deallocate(a0, v19);\n
                v14 = 0;\n
            }\n
            else\n
            {\n
                v5 = v14;\n
                cgc_bzero(v5, cgc_strlen(v14) + 1);\n
                v6 = v14;\n
                cgc_strlen(v14);\n
                cgc_deallocate(a0, a1);\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 125))\n
                {\n
                    v18 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                    goto LABEL_40b1ed;\n
                }\n
                if (cgc_skipLength(a0, 1) == -1)\n
                {\n
                    v18 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                    goto LABEL_40b209;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                v10 = a0->field_c;\n
                v9 = cgc_skipFloat(a0);\n
                if (v9 == -1)\n
                {\n
                    v18 = cgc_printf(\"!!Failed to locate the end of the period data\\n
\", 1, a2, a3, a4);\n
                    v15 = 0xbff0000000000000;\n
                    return v18;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v18 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else if (cgc_skipLength(a0, 1) == -1)\n
                {\n
                    v18 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                    goto LABEL_40b1ed;\n
                }\n
                else\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v18 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v15 = 0xbff0000000000000;\n
                        return v18;\n
                    }\n
                    v12 = cgc_skipLength(a0, 1);\n
                    if (v12 == -1)\n
                    {\n
                        v18 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                    }\n
                    else\n
                    {\n
                        v11 = cgc_skipToNonAlphaNum(a0);\n
                        if (v11 == -1)\n
                        {\n
                            v18 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                            v15 = 0xbff0000000000000;\n
                            return v18;\n
                        }\n
                        v14 = cgc_copyData(a0, v12, v11);\n
                        if (cgc_strcmp(v14, \"OrbitSpeed\"))\n
                        {\n
                            cgc_printf(\"!!Invalid closing element id: @s\\n
\", v14, a2, a3, a4);\n
                            v3 = v14;\n
                            cgc_bzero(v3, cgc_strlen(v14) + 1);\n
                            v4 = v14;\n
                            cgc_strlen(v14);\n
                            v18 = cgc_deallocate(a0, a1);\n
                            v15 = 0xbff0000000000000;\n
                            return v18;\n
                        }\n
                        v1 = v14;\n
                        cgc_bzero(v1, cgc_strlen(v14) + 1);\n
                        v2 = v14;\n
                        cgc_strlen(v14);\n
                        cgc_deallocate(a0, a1);\n
                        cgc_skipWhiteSpace(a0);\n
                        if (!cgc_atChar(a0, 125))\n
                        {\n
                            v18 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        }\n
                        else\n
                        {\n
                            cgc_skipLength(a0, 1);\n
                            v14 = cgc_copyData(a0, v10, v9);\n
                            if (!v14)\n
                            {\n
                                v18 = cgc_printf(\"!!Failed to copy period data\\n
\", a1, a2, a3, a4);\n
                            }\n
                            else\n
                            {\n
                                cgc_atof(v14);\n
                                v13 = 0xbff0000000000000;\n
                                v0 = v14;\n
                                cgc_strlen(v14);\n
                                v18 = cgc_deallocate(a0, a1);\n
                            }\n
LABEL_40b209:\n
                            v15 = v13;\n
                            return v18;\n
                        }\n
LABEL_40b1ed:\n
                        v13 = 0xbff0000000000000;\n
                        v15 = v13;\n
                        return v18;\n
                    }\n
                }\n
            }\n
        }\n
    }\n
    v15 = 0xbff0000000000000;\n
    return v18;\n
}\n
", "4239905:sub_40b221": null, "4239920:cgc_extractAphelion": "long long cgc_extractAphelion(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Aphelion\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Aphelion\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the period data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_skipLength(a0, 1) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Aphelion\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Aphelion\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy period data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Aphelion\\\"\\n
\", \"Aphelion\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Aphelion\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4241215:sub_40b73f": null, "4241216:cgc_extractPerihelion": "long long cgc_extractPerihelion(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Perihelion\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Perihelion\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the perihelion data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Perihelion\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Perihelion\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy perihelion data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Perihelion\\\"\\n
\", \"Perihelion\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Perihelion\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4242506:sub_40bc4a": null, "4242512:cgc_extractRadius": "long long cgc_extractRadius(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_incChar(a0) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 123, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Radius\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Radius\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_incChar(a0) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the radius data\\n
\", 125, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_incChar(a0);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Radius\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Radius\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy radius data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Radius\\\"\\n
\", \"Radius\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Radius\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4243787:sub_40c14b": null, "4243792:cgc_extractERadius": "long long cgc_extractERadius(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"ERadius\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"ERadius\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the eradius data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"ERadius\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"ERadius\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy eradius data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"ERadius\\\"\\n
\", \"ERadius\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"ERadius\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4245082:sub_40c65a": null, "4245088:cgc_extractMass": "long long cgc_extractMass(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Mass\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Mass\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the mass data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Mass\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Mass\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy mass data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Mass\\\"\\n
\", \"Mass\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Mass\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4246378:sub_40cb6a": null, "4246384:cgc_extractGravity": "long long cgc_extractGravity(unsigned long long a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x38]\n
    unsigned int v6;  // [bp-0x34]\n
    unsigned int v7;  // [bp-0x30]\n
    unsigned int v8;  // [bp-0x2c]\n
    unsigned long long v9;  // [bp-0x28]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned long v11;  // [bp-0x10], Other Possible Types: unsigned long long\n
    unsigned long v13;  // rax, Other Possible Types: unsigned long long\n
\n
    v10 = 0;\n
    v9 = 0xbff0000000000000;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v11 = 0xbff0000000000000;\n
        return v13;\n
    }\n
    v8 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        v13 = cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipToNonAlphaNum(a0);\n
        if (v7 == -1)\n
        {\n
            v13 = cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v13;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            v13 = cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
            v11 = 0xbff0000000000000;\n
            return v13;\n
        }\n
        else if (!cgc_strcmp(v10, \"Gravity\"))\n
        {\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Gravity\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                v13 = cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v11 = 0xbff0000000000000;\n
                return v13;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipFloat(a0);\n
                if (v5 == -1)\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the end of the gravity data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    v13 = cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = 0xbff0000000000000;\n
                    return v13;\n
                }\n
                else if (cgc_incChar(a0) != -1)\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v8 = cgc_skipLength(a0, 1);\n
                    if (v8 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v7 = cgc_skipToNonAlphaNum(a0);\n
                    if (v7 == -1)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    v10 = cgc_copyData(a0, v8, v7);\n
                    if (cgc_strcmp(v10, \"Gravity\"))\n
                    {\n
                        cgc_printf(\"!!Invalid closing element id: @s\\n
\", v10, a2, a3, a4);\n
                        v2 = v10;\n
                        cgc_strlen(v10);\n
                        v13 = cgc_deallocate(a0, a1);\n
                        v11 = v9;\n
                        return v13;\n
                    }\n
                    v1 = v10;\n
                    cgc_strlen(v10);\n
                    cgc_deallocate(a0, \"Gravity\");\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 125))\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_skipLength(a0, 1);\n
                    v10 = cgc_copyData(a0, v6, v5);\n
                    if (!v10)\n
                    {\n
                        v13 = cgc_printf(\"!!Failed to copy gravity data\\n
\", a1, a2, a3, a4);\n
                        v11 = 0xbff0000000000000;\n
                        return v13;\n
                    }\n
                    cgc_atof(v10);\n
                    v9 = 0xbff0000000000000;\n
                    v0 = v10;\n
                    cgc_strlen(v10);\n
                    v13 = cgc_deallocate(a0, a1);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
                else\n
                {\n
                    v13 = cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                    v11 = v9;\n
                    return v13;\n
                }\n
            }\n
            else\n
            {\n
                v13 = cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v11 = v9;\n
                return v13;\n
            }\n
        }\n
        else\n
        {\n
            cgc_printf(\"!!Element id is not \\\"Gravity\\\"\\n
\", \"Gravity\", a2, a3, a4);\n
            v4 = v10;\n
            cgc_strlen(v10);\n
            v13 = cgc_deallocate(a0, \"Gravity\");\n
            v10 = 0;\n
            v11 = v9;\n
            return v13;\n
        }\n
    }\n
    else\n
    {\n
        v13 = cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v11 = v9;\n
        return v13;\n
    }\n
}\n
", "4247674:sub_40d07a": null, "4247680:main": "typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
extern unsigned long long g_4112d4[4];\n
extern struct_1 solarSystem;\n
\n
int main(unsigned long long a0, unsigned long long a1, unsigned long long a2, unsigned long long a3[4], unsigned int a4)\n
{\n
    char v0;  // [bp-0x79]\n
    struct_0 *v1;  // [bp-0x78]\n
    unsigned long v2;  // [bp-0x70]\n
    void* v3;  // [bp-0x60], Other Possible Types: unsigned long\n
    void* v4;  // [bp-0x58], Other Possible Types: char *\n
    unsigned long long *v5;  // [bp-0x50]\n
    char v6;  // [bp-0x48]\n
    unsigned int v7;  // [bp-0x1c]\n
    unsigned long v8;  // [bp-0x18]\n
    unsigned int v9;  // [bp-0x10]\n
    unsigned int v10;  // [bp-0xc]\n
    unsigned long v12;  // rax\n
\n
    v10 = 0;\n
    v9 = a0;\n
    v8 = a1;\n
    v7 = 0;\n
    v5 = 0;\n
    v4 = 0;\n
    v3 = 0;\n
    cgc_bzero(&solarSystem.field_0, 80);\n
    while (true)\n
    {\n
        while (true)\n
        {\n
            v0 = 0;\n
            cgc_printf(\"\\n
Planet Markup Language Main\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"1) Print Planets\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"2) Add PML\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"3) Add Planet\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"4) Select Planet\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"5) Exit\\n
\", a1, a2, a3, a4);\n
            cgc_printf(\"Selection: \", a1, a2, a3, a4);\n
            v1 = &v6;\n
            cgc_bzero(&v6, 30);\n
            cgc_receive_until(v1, 10, 4);\n
            v7 = cgc_atoi(v1);\n
            v12 = v7 - 1;\n
            a3 = v12;\n
            v2 = v12;\n
            switch (v12)\n
            {\n
            case 0:\n
                for (v7 = 0; v7 < 10; v7 += 1)\n
                {\n
                    a3 = v7;\n
                    if (*(&(&solarSystem.field_0)[8 * a3]))\n
                        cgc_printPlanetInfo(*(&(&solarSystem.field_0)[8 * v7]), 10, 4, v7, a4);\n
                }\n
                break;\n
            case 1:\n
                if (cgc_allocate(a0, 10, 4))\n
                {\n
                    v3 = 0;\n
                    continue;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"PML: \", 10, 4, &g_4112d4[0], a4);\n
                    cgc_bzero(v3, 0x1000);\n
                    cgc_receive_until(v3, 10, 4095);\n
                    v5 = cgc_initString(v3);\n
                    cgc_deallocate(a0, 10);\n
                    if (!v5)\n
                        continue;\n
                    if (*(v5))\n
                    {\n
                        v7 = 0;\n
                        while (v7 < 10)\n
                        {\n
                            a3 = v7;\n
                            if (*(&(&solarSystem.field_0)[8 * a3]))\n
                            {\n
                                v7 += 1;\n
                            }\n
                            else\n
                            {\n
                                a2 = cgc_planetTopLevel(v5, 10, a2, a3, a4);\n
                                *(&(&solarSystem.field_0)[8 * v7]) = a2;\n
                                a3 = v7;\n
                                if (!*(&(&solarSystem.field_0)[8 * a3]))\n
                                    break;\n
                                v7 += 1;\n
                                goto LABEL_40d300;\n
                            }\n
                        }\n
                    }\n
                    else\n
                    {\n
                        cgc_deallocate(a0, 10);\n
                        continue;\n
                    }\n
                }\n
            case 2:\n
                cgc_printf(\"\\n
-> \", 10, 4, &g_4112d4[0], a4);\n
                cgc_bzero(&v6, 30);\n
                a1 = 10;\n
                a2 = 29;\n
                cgc_receive_until(&v6, 10, 29);\n
                for (v7 = 0; v7 < 10; v7 += 1)\n
                {\n
                    a3 = v7;\n
                    if (!*(&(&solarSystem.field_0)[8 * a3]))\n
                        break;\n
                }\n
                if (v7 == 10)\n
                    continue;\n
                if (cgc_allocate(\"\\n
-> \", 10, 29))\n
                {\n
                    v4 = 0;\n
                    break;\n
                }\n
                else\n
                {\n
                    cgc_initPlanet(v4);\n
                    *(&(&solarSystem.field_0)[8 * v7]) = v4;\n
                    for (v7 = 0; cgc_isalnum((&v6)[v7]); v7 += 1)\n
                    {\n
                        v4[v7] = (&v6)[v7];\n
                    }\n
                }\n
            case 3:\n
                for (v7 = 0; v7 < 10; v7 += 1)\n
                {\n
                    if (*(&(&solarSystem.field_0)[8 * v7]))\n
                    {\n
                        a3 = v7;\n
                        cgc_printf(\"@d) @s\\n
\", v7 + 1, *(&(&solarSystem.field_0)[8 * a3]), a3, a4);\n
                    }\n
                }\n
                cgc_bzero(&v6, 30);\n
                cgc_printf(\"\\n
-> \", 30, a2, a3, a4);\n
                a1 = 10;\n
                a2 = 4;\n
                cgc_receive_until(&v6, 10, 4);\n
                v7 = cgc_atoi(&v6);\n
                if (v7 >= 1 && v7 <= 10)\n
                {\n
                    a3 = v7 - 1;\n
                    if (*(&(&solarSystem.field_0)[8 * a3]))\n
                    {\n
                        a3 = v7 - 1;\n
                        if (!cgc_planetMenu(*((&solarSystem.field_0 + 0x8 * a3)), 10, 4, a3, a4))\n
                        {\n
                            a3 = v7 - 1;\n
                            *(&(&solarSystem.field_0)[8 * a3]) = 0;\n
                        }\n
                        break;\n
                    }\n
                    else\n
                    {\n
                        cgc_printf(\"Invalid\\n
\", 10, 4, a3, a4);\n
                        continue;\n
                    }\n
                }\n
                cgc_printf(\"Invalid\\n
\", 10, 4, a3, a4);\n
                continue;\n
            case 4:\n
                cgc_printf(\"Exitting..\\n
\", 10, 4, &g_4112d4[0], a4);\n
                return 0;\n
            default:\n
                cgc_printf(\"Invalid...\\n
\", 10, 4, v12, a4);\n
LABEL_40d55f:\n
                continue;\n
            }\n
        }\n
LABEL_40d300:\n
        cgc_freeString(v5);\n
        goto LABEL_40d55f;\n
    }\n
}\n
", "4248932:sub_40d564": null, "4248944:cgc_freeString": "long long cgc_freeString(unsigned long long *a0)\n
{\n
    unsigned long long v1;  // rsi\n
    unsigned long long v2;  // rax\n
\n
    if (!a0)\n
        return v2;\n
    if (*(a0))\n
        cgc_deallocate(a0, v1);\n
    v2 = cgc_deallocate(a0, v1);\n
    return v2;\n
}\n
", "4249026:sub_40d5c2": null, "4249040:cgc_skipUrl": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipUrl(struct_0 *a0)\n
{\n
    char v0;  // [bp-0x19]\n
    unsigned int v1;  // [bp-0x18]\n
    unsigned int v2;  // [bp-0x14]\n
\n
    v2 = -1;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v2;\n
    for (v1 = a0->field_c; v1 < a0->field_8; v1 += 1)\n
    {\n
        v0 = *((a0->field_0 + v1));\n
        if (!cgc_isalnum(v0) && v0 != 46 && v0 != 47 && v0 != 58)\n
        {\n
            a0->field_c = v1;\n
            v2 = v1;\n
            break;\n
        }\n
    }\n
    return v2;\n
}\n
", "4249235:sub_40d693": null, "4249248:cgc_getIndex": "typedef struct struct_0 {\n
    char padding_0[12];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_getIndex(struct_0 *a0, unsigned int *a1)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (!a0)\n
    {\n
        v0 = -1;\n
        return v0;\n
    }\n
    *(a1) = a0->field_c;\n
    v0 = a0->field_c;\n
    return v0;\n
}\n
", "4249311:sub_40d6df": null, "4249312:cgc_skipInt": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipInt(struct_0 *a0)\n
{\n
    char v0;  // [bp-0x21]\n
    unsigned int v1;  // [bp-0x20]\n
    unsigned int v2;  // [bp-0x1c]\n
    unsigned int v3;  // [bp-0xc]\n
\n
    v2 = -1;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v3 = -1;\n
        return v3;\n
    }\n
    for (v1 = a0->field_c; v1 < a0->field_8; v1 += 1)\n
    {\n
        v0 = *((a0->field_0 + v1));\n
        if (v0 != 43 && v0 != 45 && !cgc_isdigit(v0))\n
        {\n
            a0->field_c = v1;\n
            v2 = a0->field_c;\n
            break;\n
        }\n
    }\n
    v3 = v2;\n
    return v3;\n
}\n
", "4249501:sub_40d79d": null, "4249504:cgc_skipFloat": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipFloat(struct_0 *a0)\n
{\n
    char v0;  // [bp-0x21]\n
    unsigned int v1;  // [bp-0x20]\n
    unsigned int v2;  // [bp-0x1c]\n
    unsigned int v3;  // [bp-0xc]\n
\n
    v2 = -1;\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v3 = -1;\n
        return v3;\n
    }\n
    for (v1 = a0->field_c; v1 < a0->field_8; v1 += 1)\n
    {\n
        v0 = *((a0->field_0 + v1));\n
        if (v0 != 46 && v0 != 43 && v0 != 45 && !cgc_isdigit(v0))\n
        {\n
            a0->field_c = v1;\n
            v2 = a0->field_c;\n
            break;\n
        }\n
    }\n
    v3 = v2;\n
    return v3;\n
}\n
", "4249716:sub_40d874": null, "4249728:cgc_copyData": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
} struct_0;\n
\n
long long cgc_copyData(struct_0 *a0, unsigned long long a1, unsigned long long a2)\n
{\n
    unsigned int v0;  // [bp-0x2c]\n
    void* v1;  // [bp-0x28]\n
    void* v2;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v2 = v1;\n
        return v2;\n
    }\n
    if (a2 >= 0 && a1 >= 0)\n
    {\n
        if (a2 == a1)\n
        {\n
            v2 = 0;\n
            return v2;\n
        }\n
        else if (a2 >= a1)\n
        {\n
            if (a0->field_8 >= a2 && a0->field_8 >= a1)\n
            {\n
                v0 = a2 - a1;\n
                if (cgc_allocate(a0, a1, a2))\n
                {\n
                    v1 = 0;\n
                    v2 = v1;\n
                    return v2;\n
                }\n
                cgc_bzero(v1, v0 + 1);\n
                cgc_memcpy(v1, a0->field_0 + a1, v0);\n
                v2 = v1;\n
                return v2;\n
            }\n
            v2 = v1;\n
            return v2;\n
        }\n
        else\n
        {\n
            v2 = v1;\n
            return v2;\n
        }\n
    }\n
    v2 = 0;\n
    return v2;\n
}\n
", "4250035:sub_40d9b3": null, "4250048:cgc_skipAlpha": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipAlpha(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x20]\n
    unsigned int v1;  // [bp-0x1c]\n
    unsigned int v2;  // [bp-0xc]\n
\n
    v1 = -1;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v2 = v1;\n
        return v2;\n
    }\n
    v0 = a0->field_c;\n
    while (true)\n
    {\n
        if (v0 >= a0->field_8)\n
        {\n
            v2 = v1;\n
            return v2;\n
        }\n
        else if (cgc_isalpha(*((a0->field_0 + v0))))\n
        {\n
            v0 += 1;\n
        }\n
        else\n
        {\n
            a0->field_c = v0;\n
            v1 = a0->field_c;\n
            v2 = v1;\n
            return v2;\n
        }\n
    }\n
}\n
", "4250211:sub_40da63": null, "4250224:cgc_skipToNonAlphaNumSpace": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipToNonAlphaNumSpace(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x20]\n
    unsigned int v1;  // [bp-0x1c]\n
    unsigned int v2;  // [bp-0xc]\n
\n
    v1 = -1;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v2 = v1;\n
        return v2;\n
    }\n
    v0 = a0->field_c;\n
    while (true)\n
    {\n
        if (v0 >= a0->field_8)\n
        {\n
            v2 = v1;\n
            return v2;\n
        }\n
        if (!cgc_isalnum(*((a0->field_0 + v0))) && *((a0->field_0 + v0)) != 32)\n
        {\n
            a0->field_c = v0;\n
            v1 = a0->field_c;\n
            v2 = v1;\n
            return v2;\n
        }\n
        v0 += 1;\n
    }\n
}\n
", "4250411:sub_40db2b": null, "4250416:cgc_skipToNonAlphaNum": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipToNonAlphaNum(struct_0 *a0)\n
{\n
    unsigned int v0;  // [bp-0x20]\n
    unsigned int v1;  // [bp-0x1c]\n
    unsigned int v2;  // [bp-0xc]\n
\n
    v1 = -1;\n
    v0 = 0;\n
    if (!a0)\n
    {\n
        v2 = v1;\n
        return v2;\n
    }\n
    v0 = a0->field_c;\n
    while (true)\n
    {\n
        if (v0 >= a0->field_8)\n
        {\n
            v2 = v1;\n
            return v2;\n
        }\n
        else if (cgc_isalnum(*((a0->field_0 + v0))))\n
        {\n
            v0 += 1;\n
        }\n
        else\n
        {\n
            a0->field_c = v0;\n
            v1 = a0->field_c;\n
            v2 = v1;\n
            return v2;\n
        }\n
    }\n
}\n
", "4250579:sub_40dbd3": null, "4250592:cgc_incChar": "long long cgc_incChar(unsigned int a0[4])\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned int v1[4];  // [bp-0x10]\n
    unsigned int v3[4];  // rax\n
\n
    *(&v1[0]) = a0;\n
    v0 = -1;\n
    if (!a0)\n
        return v0;\n
    if (a0[3] + 1 >= v1[2])\n
        return v0;\n
    v3 = a0;\n
    v3[3] = v3[3] + 1;\n
    v0 = a0[3];\n
}\n
", "4250679:sub_40dc37": null, "4250688:cgc_skipLength": "long long cgc_skipLength(unsigned int a0[4], unsigned long a1)\n
{\n
    unsigned int v0;  // [bp-0x18]\n
    unsigned int v1[4];  // [bp-0x10]\n
    unsigned int v3[4];  // rax\n
\n
    *(&v1[0]) = a0;\n
    v0 = -1;\n
    if (!a0)\n
        return v0;\n
    if (v1[3] + a1 >= a0[2])\n
        return v0;\n
    v3 = a0;\n
    v3[3] = a1 + v3[3];\n
    v0 = a0[3];\n
}\n
", "4250778:sub_40dc9a": null, "4250784:cgc_atChar": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_atChar(struct_0 *a0, unsigned long a1)\n
{\n
    unsigned int v0;  // [bp-0xc]\n
\n
    if (!a0)\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
    else if (*((a0->field_0 + a0->field_c)) != a1)\n
    {\n
        v0 = 0;\n
        return v0;\n
    }\n
    else\n
    {\n
        v0 = 1;\n
        return v0;\n
    }\n
}\n
", "4250876:sub_40dcfc": null, "4250880:cgc_skipTo": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipTo(struct_0 *a0, unsigned long a1)\n
{\n
    unsigned int v0;  // [bp-0x1c]\n
    unsigned int v1;  // [bp-0x18]\n
\n
    v1 = 0;\n
    v0 = -1;\n
    if (!a0)\n
        return v0;\n
    v1 = a0->field_c;\n
    while (true)\n
    {\n
        if (v1 >= a0->field_8)\n
            return v0;\n
        if (*((a0->field_0 + v1)) == a1)\n
        {\n
            a0->field_c = v1;\n
            v0 = v1;\n
            return v0;\n
        }\n
        v1 += 1;\n
    }\n
}\n
", "4251022:sub_40dd8e": null, "4251024:cgc_initString": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[7];\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_initString(unsigned long a0)\n
{\n
    unsigned int v0;  // [bp-0x1c]\n
    struct_0 *v1;  // [bp-0x18], Other Possible Types: unsigned long\n
    unsigned long long v3;  // rsi\n
    unsigned long long v4;  // rdx\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v1;\n
    v0 = cgc_strlen(a0) + 1;\n
    if (cgc_allocate(a0, v3, v4))\n
    {\n
        v1 = 0;\n
        return v1;\n
    }\n
    if (cgc_allocate(a0, v3, v4))\n
    {\n
        cgc_deallocate(a0, v3);\n
        v1 = 0;\n
    }\n
    cgc_bzero(*(v1), v0);\n
    cgc_memcpy(*(v1), a0, v0 - 1);\n
    *((v1 + 8)) = v0;\n
    *((v1 + 12)) = 0;\n
    return v1;\n
}\n
", "4251239:sub_40de67": null, "4251248:cgc_skipWhiteSpace": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    unsigned int field_8;\n
    unsigned int field_c;\n
} struct_0;\n
\n
long long cgc_skipWhiteSpace(struct_0 *a0)\n
{\n
    char v0;  // [bp-0x23]\n
    char v1;  // [bp-0x22]\n
    char v2;  // [bp-0x21]\n
    unsigned int v3;  // [bp-0x20]\n
    unsigned int v4;  // [bp-0x1c]\n
    unsigned int v5;  // [bp-0xc]\n
\n
    v4 = -1;\n
    v3 = 0;\n
    v2 = 0;\n
    if (a0)\n
    {\n
        if (a0->field_8 > a0->field_c)\n
        {\n
            v3 = a0->field_c;\n
            while (true)\n
            {\n
                v1 = 0;\n
                if (v3 < a0->field_8)\n
                {\n
                    v0 = 1;\n
                    if (*((a0->field_0 + v3)) != 10)\n
                    {\n
                        v0 = 1;\n
                        if (*((a0->field_0 + v3)) != 9)\n
                        {\n
                            v0 = 1;\n
                            if (*((a0->field_0 + v3)) != 32)\n
                                v0 = *((a0->field_0 + v3)) == 13;\n
                        }\n
                    }\n
                    v1 = v0;\n
                }\n
                if (!(v1 & 1))\n
                    break;\n
                v3 += 1;\n
            }\n
            v4 = v3;\n
            a0->field_c = v3;\n
        }\n
        else\n
        {\n
            v5 = -1;\n
            return v5;\n
        }\n
    }\n
    v5 = v4;\n
    return v5;\n
}\n
", "4251527:sub_40df87": null, "4251536:cgc_territoryMenu": "typedef struct struct_0 {\n
    char field_0;\n
} struct_0;\n
\n
extern unsigned int g_411360;\n
\n
long long cgc_territoryMenu(unsigned int a0[217], unsigned int a1, unsigned long long a2, unsigned long a3, unsigned int a4)\n
{\n
    char v0;  // [bp-0x72]\n
    char v1;  // [bp-0x71]\n
    struct_0 *v2;  // [bp-0x70]\n
    unsigned long v3;  // [bp-0x68]\n
    void* v4;  // [bp-0x60], Other Possible Types: char *\n
    unsigned long long v5[4];  // [bp-0x58], Other Possible Types: unsigned long\n
    void* v6;  // [bp-0x50]\n
    char v7;  // [bp-0x48]\n
    void* v8;  // [bp-0x28]\n
    unsigned int v9;  // [bp-0x1c]\n
    unsigned int v10;  // [bp-0xc]\n
    unsigned long v12;  // rax\n
    unsigned long v13;  // xmm0lq\n
\n
    v9 = 0;\n
    v8 = 0;\n
    v6 = 0;\n
    v5[0] = 0;\n
    v4 = 0;\n
    if (!a0)\n
    {\n
        v10 = 0;\n
        return v10;\n
    }\n
    while (true)\n
    {\n
        v1 = 0;\n
        cgc_printf(\"\\n
Territory: @s\\n
\", a0, a2, a3, a4);\n
        cgc_printf(\"1) Display Territory Info\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"2) Set Founder\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"3) Set Population\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"4) Set Established\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"5) Add Border\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"6) Add County\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"7) Select County\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"8) Delete County and Exit Menu\\n
\", a1, a2, a3, a4);\n
        cgc_printf(\"9) Exit Menu\\n
\", a1, a2, a3, a4);\n
        v2 = &v7;\n
        cgc_bzero(&v7, 4);\n
        cgc_printf(\"Selection: \", 4, a2, a3, a4);\n
        cgc_receive_until(v2, 10, 3);\n
        v9 = cgc_atoi(v2);\n
        cgc_bzero(v2, 30);\n
        v12 = v9 - 1;\n
        a3 = v12;\n
        v3 = v12;\n
        switch (v12)\n
        {\n
        case 0:\n
            cgc_printTerritoryInfo(a0);\n
            break;\n
        case 1:\n
            cgc_printf(\"\\n
-> \", 30, 3, &g_411360, a4);\n
            a2 = 29;\n
            cgc_receive_until(&v7, 10, 29);\n
            v9 = 0;\n
            while (true)\n
            {\n
                v0 = 1;\n
                if (!cgc_isalnum((&v7)[v9]))\n
                    v0 = (&v7)[v9] == 32;\n
                if (!(v0 & 1))\n
                    break;\n
                *(20 + &a0[0] + v9) = (&v7)[v9];\n
                v9 += 1;\n
            }\n
            a3 = v9;\n
            *(20 + &a0[0] + a3) = 0;\n
            break;\n
        case 2:\n
            cgc_printf(\"\\n
-> \", 30, 3, &g_411360, a4);\n
            a2 = 29;\n
            cgc_receive_until(&v7, 10, 29);\n
            a3 = cgc_atoi(&v7);\n
            a0[13] = a3;\n
            break;\n
        case 3:\n
            cgc_printf(\"\\n
-> \", 30, 3, &g_411360, a4);\n
            a2 = 29;\n
            cgc_receive_until(&v7, 10, 29);\n
            a3 = cgc_atoi(&v7);\n
            a0[14] = a3;\n
            break;\n
        case 4:\n
            if (a0[15] >= 100)\n
            {\n
                cgc_printf(\"!!Max borders reached\\n
\", 30, 3, &g_411360, a4);\n
                continue;\n
            }\n
            else if (!cgc_allocate(a0, 30, 3))\n
            {\n
                cgc_printf(\"Lat Start: \", 30, 3, &g_411360, a4);\n
                cgc_bzero(&v7, 30);\n
                cgc_receive_until(&v7, 10, 19);\n
                cgc_atof(&v7);\n
                *(v5) = v13;\n
                cgc_printf(\"Long Start: \", 10, 19, &g_411360, a4);\n
                cgc_bzero(&v7, 30);\n
                cgc_receive_until(&v7, 10, 19);\n
                cgc_atof(&v7);\n
                *((v5 + 8)) = v13;\n
                cgc_printf(\"Lat End: \", 10, 19, &g_411360, a4);\n
                cgc_bzero(&v7, 30);\n
                cgc_receive_until(&v7, 10, 19);\n
                cgc_atof(&v7);\n
                *((v5 + 16)) = v13;\n
                cgc_printf(\"Long End: \", 10, 19, &g_411360, a4);\n
                cgc_bzero(&v7, 30);\n
                cgc_receive_until(&v7, 10, 19);\n
                cgc_atof(&v7);\n
                *((v5 + 24)) = v13;\n
                a2 = v5;\n
                *(&a0[16 + 2 * a0[15]]) = a2;\n
                a3 = a0[15] + 1;\n
                a0[15] = a3;\n
                break;\n
            }\n
            else\n
            {\n
                v5 = 0;\n
                continue;\n
            }\n
        case 5:\n
            for (v9 = 0; v9 < 10; v9 += 1)\n
            {\n
                a3 = v9;\n
                if (!*(&a0[1 + 1 + 2 * a3]))\n
                    break;\n
            }\n
            if (v9 == 10)\n
            {\n
                cgc_printf(\"!!Max counties reached\\n
\", 30, 3, a3, a4);\n
                continue;\n
            }\n
            else\n
            {\n
                cgc_printf(\"\\n
New County Name: \", 30, 3, a3, a4);\n
                a2 = 19;\n
                cgc_receive_until(&v7, 10, 19);\n
                if (!cgc_allocate(\"\\n
New County Name: \", 10, 19))\n
                {\n
                    cgc_initCounty(v4);\n
                    *(&a0[1 + 1 + 2 * v9]) = v4;\n
                    for (v9 = 0; cgc_isalnum((&v7)[v9]); v9 += 1)\n
                    {\n
                        v4[v9] = (&v7)[v9];\n
                    }\n
                    v4[v9] = 0;\n
                    a3 = a0[216] + 1;\n
                    a0[216] = a3;\n
                    break;\n
                }\n
                else\n
                {\n
                    v4 = 0;\n
                    continue;\n
                }\n
            }\n
        case 6:\n
            for (v9 = 0; v9 < 10; v9 += 1)\n
            {\n
                a3 = v9;\n
                if (*(&a0[1 + 1 + 2 * a3]))\n
                {\n
                    a3 = v9;\n
                    cgc_printf(\"@d) @s\\n
\", v9 + 1, *(&a0[1 + 1 + 2 * a3]), a3, a4);\n
                }\n
            }\n
            cgc_printf(\"\\n
-> \", a1, a2, a3, a4);\n
            a2 = 19;\n
            cgc_receive_until(&v7, 10, 19);\n
            v9 = cgc_atoi(&v7);\n
            if (v9 >= 1 && v9 <= 10)\n
            {\n
                a3 = v9 - 1;\n
                if (*(&a0[1 + 1 + 2 * a3]))\n
                {\n
                    a3 = v9 - 1;\n
                    if (!cgc_countyMenu(*(&a0[1 + 1 + 2 * a3]), 10, 19, a3, a4))\n
                    {\n
                        *(&a0[216 + 2 * v9]) = 0;\n
                        a3 = a0[216] - 1;\n
                        a0[216] = a3;\n
                    }\n
                    break;\n
                }\n
                else\n
                {\n
                    cgc_printf(\"Invalid choice...\\n
\", 10, 19, a3, a4);\n
                    continue;\n
                }\n
            }\n
            cgc_printf(\"Invalid choice...\\n
\", 10, 19, a3, a4);\n
            continue;\n
        case 7:\n
            cgc_freeTerritory(a0);\n
            v10 = 0;\n
            return v10;\n
        case 8:\n
            v10 = 1;\n
            return v10;\n
        default:\n
            cgc_printf(\"Invalid\\n
\", 30, 3, v12, a4);\n
            continue;\n
        }\n
    }\n
}\n
", "4253199:sub_40e60f": null, "4253200:cgc_printTerritoryInfo": "typedef struct struct_0 {\n
    char field_0;\n
    char padding_1[19];\n
    char field_14;\n
    char padding_15[31];\n
    unsigned int field_34;\n
    unsigned int field_38;\n
    unsigned int field_3c;\n
} struct_0;\n
\n
long long cgc_printTerritoryInfo(struct_0 *a0, unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    void* v0;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned int v1;  // [bp-0x14]\n
    unsigned long long v3;  // rax, Other Possible Types: unsigned long\n
    unsigned long v4;  // rcx\n
\n
    v1 = 0;\n
    v0 = 0;\n
    if (!a0)\n
        return v3;\n
    cgc_printf(\"\\t\\tTerritory: \", a1, a2, a3, a4);\n
    if (a0->field_0)\n
        cgc_printf(\"@s\\n
\", a0, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    if (a0->field_34 >= 0)\n
        cgc_printf(\"\\t\\t\\tPopulation: @d\\n
\", a0->field_34, a2, a3, a4);\n
    cgc_printf(\"\\t\\t\\tEstablished: @d\\n
\", a0->field_38, a2, a3, a4);\n
    cgc_printf(\"\\t\\t\\tFounder: \", a1, a2, a3, a4);\n
    if (a0->field_14)\n
        cgc_printf(\"@s\\n
\", &a0->field_14, a2, a3, a4);\n
    else\n
        cgc_printf(\"Unknown\\n
\", a1, a2, a3, a4);\n
    v1 = 0;\n
    while (true)\n
    {\n
        v3 = v1;\n
        if (v3 >= a0->field_3c)\n
            break;\n
        v4 = v1;\n
        v0 = *(&(&a0[1].field_0)[8 * v4]);\n
        if (v0)\n
            cgc_printf(\"\\t\\t\\tBorder: @f @f @f @f\\n
\", a1, a2, v4, a4);\n
        v1 += 1;\n
    }\n
    v1 = 0;\n
    for (v1 = 0; v1 < 10; v1 = v3)\n
    {\n
        if (*(&a0[13].padding_15[19 + 8 * v1]))\n
            cgc_printCountyInfo(*(&a0[13].padding_15[19 + 8 * v1]), a1, a2, v1, a4);\n
        v3 = v1 + 1;\n
    }\n
    return v3;\n
}\n
", "4253650:sub_40e7d2": null, "4253664:cgc_freeTerritory": "long long cgc_freeTerritory(unsigned int a0[217])\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rsi\n
    unsigned long long v3;  // rax\n
\n
    if (!a0)\n
        return v3;\n
    for (v0 = 0; v0 < a0[15]; v0 += 1)\n
    {\n
        if (*(&a0[16 + 2 * v0]))\n
        {\n
            cgc_deallocate(a0, v2);\n
            *(&a0[16 + 2 * v0]) = 0;\n
        }\n
    }\n
    for (v0 = 0; v0 < a0[216]; v0 += 1)\n
    {\n
        cgc_freeCounty(*(&a0[1 + 1 + 2 * v0]));\n
        *(&a0[1 + 1 + 2 * v0]) = 0;\n
    }\n
    v3 = cgc_deallocate(a0, v2);\n
    return v3;\n
}\n
", "4253895:sub_40e8c7": null, "4253904:cgc_initTerritory": "long long cgc_initTerritory(unsigned int a0[217])\n
{\n
    unsigned int v0;  // [bp-0x14]\n
    unsigned long long v2;  // rax\n
\n
    v0 = 0;\n
    if (a0)\n
    {\n
        cgc_bzero(a0, 20);\n
        cgc_bzero(&a0[5], 30);\n
        a0[13] = -1;\n
        a0[216] = 0;\n
        a0[15] = 0;\n
        cgc_bzero(&a0[16], 800);\n
        v2 = cgc_bzero(&a0[1 + 1], 80);\n
        return v2;\n
    }\n
    return v2;\n
}\n
", "4254052:sub_40e964": null, "4254064:cgc_territoryTopLevel": "typedef struct struct_0 {\n
    unsigned long long field_0;\n
    char padding_8[4];\n
    unsigned int field_c;\n
} struct_0;\n
\n
extern unsigned int g_411384;\n
\n
long long cgc_territoryTopLevel(struct_0 *a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x70]\n
    unsigned long v1;  // [bp-0x68]\n
    unsigned long v2;  // [bp-0x60]\n
    unsigned long v3;  // [bp-0x58]\n
    unsigned int v4;  // [bp-0x50]\n
    unsigned long v5;  // [bp-0x48]\n
    unsigned long v6;  // [bp-0x40]\n
    unsigned long v7;  // [bp-0x38]\n
    unsigned int v8;  // [bp-0x30]\n
    unsigned int v9;  // [bp-0x2c]\n
    unsigned int v10;  // [bp-0x28]\n
    unsigned int v11;  // [bp-0x24]\n
    void* v12;  // [bp-0x20], Other Possible Types: unsigned long, unsigned int\n
    unsigned int v13[217];  // [bp-0x18], Other Possible Types: unsigned long, void*\n
    unsigned long long v15;  // rax\n
    unsigned int v16[217];  // rax\n
    unsigned int v17[217];  // rax\n
    unsigned long v18;  // rcx\n
\n
    *(&v13[0]) = 0;\n
    v12 = 0;\n
    v11 = 0;\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    if (!a0)\n
    {\n
        return v13;\n
    }\n
    else if (!cgc_allocate(a0, a1, a2))\n
    {\n
        cgc_initTerritory(v13);\n
        cgc_skipWhiteSpace(a0);\n
        v11 = cgc_getIndex(a0, &v11);\n
        if (cgc_atChar(a0, 123) && cgc_incChar(a0) >= 0)\n
        {\n
            cgc_skipWhiteSpace(a0);\n
            cgc_getIndex(a0, &v10);\n
            v9 = cgc_skipAlpha(a0);\n
            if (v9 == -1)\n
            {\n
LABEL_40ea6b:\n
            }\n
            else\n
            {\n
                if (v10 == v9)\n
                    goto LABEL_40ea6b;\n
                v12 = cgc_copyData(a0, v10, v9);\n
                if (v12)\n
                {\n
                    if (cgc_strcmp(v12, \"Territory\"))\n
                    {\n
                        cgc_printf(\"!!Territory: Invalid opening element id\\n
\", \"Territory\", a2, a3, a4);\n
                        v7 = v12;\n
                        cgc_strlen(v12);\n
                        cgc_deallocate(a0, \"Territory\");\n
                    }\n
                    else\n
                    {\n
                        v6 = v12;\n
                        cgc_strlen(v12);\n
                        cgc_deallocate(a0, \"Territory\");\n
                        cgc_skipWhiteSpace(a0);\n
                        if (cgc_atChar(a0, 125))\n
                        {\n
                            cgc_incChar(a0);\n
                            v11 = a0->field_c;\n
                            *(&v12) = cgc_pullNextElementName(a0, 125, a2, a3, a4);\n
                            while (true)\n
                            {\n
                                if (!v12)\n
                                {\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (cgc_atChar(a0, 123) && cgc_skipLength(a0, 1) >= 0)\n
                                    {\n
                                        cgc_skipWhiteSpace(a0);\n
                                        if (cgc_atChar(a0, 35) && cgc_skipLength(a0, 1) >= 0)\n
                                        {\n
                                            v10 = a0->field_c;\n
                                            v9 = cgc_skipAlpha(a0);\n
                                            if (v9 >= 0 && v10 != v9)\n
                                            {\n
                                                v12 = cgc_copyData(a0, v10, v9);\n
                                                if (v12)\n
                                                {\n
                                                    if (cgc_strcmp(v12, \"Territory\"))\n
                                                    {\n
                                                        v1 = v12;\n
                                                        cgc_strlen(v12);\n
                                                        cgc_deallocate(a0, \"Territory\");\n
                                                        break;\n
                                                    }\n
                                                    else\n
                                                    {\n
                                                        v0 = v12;\n
                                                        cgc_strlen(v12);\n
                                                        cgc_deallocate(a0, \"Territory\");\n
                                                        cgc_skipWhiteSpace(a0);\n
                                                        if (cgc_atChar(a0, 125))\n
                                                        {\n
                                                            cgc_incChar(a0);\n
                                                            return v13;\n
                                                        }\n
                                                        break;\n
                                                    }\n
                                                }\n
                                            }\n
                                        }\n
                                    }\n
                                }\n
                                else\n
                                {\n
                                    v8 = cgc_elementNameToEnum(v12, a1, a2, a3, a4);\n
                                    *(&v4) = v12;\n
                                    cgc_strlen(*(&v4));\n
                                    cgc_deallocate(a0, a1);\n
                                    v15 = v8 - 1;\n
                                    a3 = v15;\n
                                    v5 = v15;\n
                                    switch (v15)\n
                                    {\n
                                    case 0:\n
                                        *(&v12) = cgc_extractName(a0, a1, a2, 4264836, a4);\n
                                        if (!v12)\n
                                            break;\n
                                        cgc_bzero(v13, 20);\n
                                        cgc_strncpy(v13, *(&v12), 19);\n
                                        v3 = *(&v12);\n
                                        cgc_strlen(*(&v12));\n
                                        cgc_deallocate(a0, a1);\n
                                        v12 = 0;\n
                                        goto LABEL_40edce;\n
                                    case 9:\n
                                        a3 = cgc_extractPopulation(a0, a1, a2, 4264836, a4);\n
                                        v13[13] = a3;\n
                                        if (v13[13] < 0)\n
                                            break;\n
                                    case 13:\n
                                        if (v13[15] >= 100)\n
                                        {\n
                                            cgc_printf(\"!!Max territory border count is @d\\n
\", 100, a2, &g_411384, a4);\n
                                            break;\n
                                        }\n
                                        else\n
                                        {\n
                                            a2 = cgc_extractBorder(a0, a1, a2, 4264836, a4);\n
                                            *(&v13[16 + 2 * v13[15]]) = a2;\n
                                            if (!*(&v13[16 + 2 * v13[15]]))\n
                                                break;\n
                                            v16 = v13;\n
                                            a3 = v16[15] + 1;\n
                                            v16[15] = a3;\n
                                            goto LABEL_40edce;\n
                                        }\n
                                    case 15:\n
                                        a3 = cgc_extractEstablished(a0);\n
                                        v13[14] = a3;\n
                                        goto LABEL_40edce;\n
                                    case 16:\n
                                        *(&v12) = cgc_extractFounder(a0);\n
                                        if (!v12)\n
                                            break;\n
                                        cgc_bzero(&v13[5], 30);\n
                                        cgc_strncpy(&v13[5], *(&v12), 29);\n
                                        v2 = *(&v12);\n
                                        cgc_strlen(*(&v12));\n
                                        cgc_deallocate(a0, a1);\n
                                        v12 = 0;\n
                                        goto LABEL_40edce;\n
                                    case 17:\n
                                        if (v13[216] >= 10)\n
                                        {\n
                                            cgc_printf(\"!!Max territory county count is @d\\n
\", 10, a2, &g_411384, a4);\n
                                            break;\n
                                        }\n
                                        else\n
                                        {\n
                                            a2 = cgc_countyTopLevel(a0, a1, a2, &g_411384, a4);\n
                                            *(&v13[1 + 1 + 2 * v13[216]]) = a2;\n
                                            if (!*(&v13[1 + 1 + 2 * v13[216]]))\n
                                                break;\n
                                            v17 = v13;\n
                                            a3 = v17[216] + 1;\n
                                            v17[216] = a3;\n
                                            goto LABEL_40edce;\n
                                        }\n
                                    default:\n
                                        cgc_printf(\"Invalid for territory\\n
\", a1, a2, a3, a4);\n
                                        break;\n
                                    }\n
LABEL_40edce:\n
                                    v11 = a0->field_c;\n
                                    v12 = cgc_pullNextElementName(a0, a1, a2, a3, a4);\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        if (v13)\n
        {\n
            cgc_freeTerritory(v13);\n
            v13 = 0;\n
        }\n
        v18 = v11;\n
        a0->field_c = v18;\n
        cgc_printf(\"Error at: @s\\n
\", a0->field_0 + a0->field_c, a2, v18, a4);\n
        return v13;\n
    }\n
    else\n
    {\n
        v13 = 0;\n
        return v13;\n
    }\n
}\n
", "4255656:sub_40efa8": null, "4255664:cgc_extractFounder": "long long cgc_extractFounder(unsigned long long *a0, unsigned long long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x58]\n
    unsigned long v1;  // [bp-0x50]\n
    unsigned long v2;  // [bp-0x48]\n
    unsigned long v3;  // [bp-0x40]\n
    unsigned long v4;  // [bp-0x38]\n
    unsigned int v5;  // [bp-0x30]\n
    unsigned int v6;  // [bp-0x2c]\n
    void* v7;  // [bp-0x28], Other Possible Types: unsigned int, unsigned long\n
    void* v8;  // [bp-0x20], Other Possible Types: unsigned long\n
    void* v9;  // [bp-0x10], Other Possible Types: unsigned long\n
\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (!a0)\n
    {\n
        v9 = 0;\n
        return v9;\n
    }\n
    v6 = cgc_skipWhiteSpace(a0);\n
    if (!cgc_atChar(a0, 123))\n
    {\n
        cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
        v9 = 0;\n
        return v9;\n
    }\n
    else if (cgc_skipLength(a0, 1) != -1)\n
    {\n
        v6 = cgc_skipWhiteSpace(a0);\n
        v5 = cgc_skipAlpha(a0);\n
        if (v5 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v9 = 0;\n
            return v9;\n
        }\n
        v8 = cgc_copyData(a0, v6, v5);\n
        if (!v8)\n
        {\n
            cgc_printf(\"!!Copy from @d to @d failed\\n
\", v6, v5, a3, a4);\n
            v9 = 0;\n
            return v9;\n
        }\n
        else if (!cgc_strcmp(v8, \"Founder\"))\n
        {\n
            v3 = v8;\n
            cgc_strlen(v8);\n
            cgc_deallocate(a0, \"Founder\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
                v9 = 0;\n
                return v9;\n
            }\n
            else if (cgc_skipLength(a0, 1) != -1)\n
            {\n
                v6 = cgc_skipWhiteSpace(a0);\n
                if (v6 == v5)\n
                {\n
                    v9 = 0;\n
                    return v9;\n
                }\n
                for (v5 = cgc_skipToNonAlphaNumSpace(a0); cgc_isspace(*((*(a0) + v5 - 1))); v5 -= 1);\n
                *(&v7) = cgc_copyData(a0, v6, v5);\n
                if (!*(&v7))\n
                {\n
                    v9 = 0;\n
                    return v9;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else if (cgc_incChar(a0) == -1)\n
                {\n
                    cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else\n
                {\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                    }\n
                    else\n
                    {\n
                        v6 = cgc_skipLength(a0, 1);\n
                        if (v6 == -1)\n
                        {\n
                            cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                        }\n
                        else\n
                        {\n
                            v5 = cgc_skipAlpha(a0);\n
                            if (v5 == -1)\n
                            {\n
                                cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                            }\n
                            else\n
                            {\n
                                v8 = cgc_copyData(a0, v6, v5);\n
                                if (cgc_strcmp(v8, \"Founder\"))\n
                                {\n
                                    v2 = v8;\n
                                    cgc_strlen(v8);\n
                                    cgc_deallocate(a0, \"Founder\");\n
                                }\n
                                else\n
                                {\n
                                    v1 = v8;\n
                                    cgc_strlen(v8);\n
                                    cgc_deallocate(a0, \"Founder\");\n
                                    cgc_skipWhiteSpace(a0);\n
                                    if (!cgc_atChar(a0, 125))\n
                                    {\n
                                        cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                                    }\n
                                    else\n
                                    {\n
                                        cgc_skipLength(a0, 1);\n
                                        goto LABEL_40f413;\n
                                    }\n
                                }\n
                            }\n
                        }\n
                    }\n
                }\n
                if (*(&v7))\n
                {\n
                    v0 = *(&v7);\n
                    cgc_strlen(*(&v7));\n
                    cgc_deallocate(a0, a1);\n
                    v7 = 0;\n
                }\n
LABEL_40f413:\n
                v9 = v7;\n
                return v9;\n
            }\n
            else\n
            {\n
                cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                v9 = 0;\n
                return v9;\n
            }\n
        }\n
        else\n
        {\n
            v4 = v8;\n
            cgc_strlen(v8);\n
            cgc_deallocate(a0, \"Founder\");\n
            v9 = 0;\n
            return v9;\n
        }\n
    }\n
    else\n
    {\n
        cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
        v9 = 0;\n
        return v9;\n
    }\n
}\n
", "4256810:sub_40f42a": null, "4256816:cgc_extractEstablished": "long long cgc_extractEstablished(void* a0, unsigned long a1, unsigned int a2, unsigned int a3, unsigned int a4)\n
{\n
    unsigned long v0;  // [bp-0x60]\n
    unsigned long v1;  // [bp-0x58]\n
    unsigned long v2;  // [bp-0x50]\n
    unsigned long v3;  // [bp-0x48]\n
    unsigned long v4;  // [bp-0x40]\n
    unsigned int v5;  // [bp-0x34]\n
    unsigned int v6;  // [bp-0x30]\n
    unsigned int v7;  // [bp-0x2c]\n
    unsigned int v8;  // [bp-0x28]\n
    unsigned int v9;  // [bp-0x24]\n
    void* v10;  // [bp-0x20], Other Possible Types: unsigned long\n
    unsigned int v11;  // [bp-0xc]\n
\n
    v10 = 0;\n
    v9 = 0;\n
    v8 = 0;\n
    v7 = 0;\n
    v6 = 0;\n
    v5 = 0;\n
    if (a0)\n
    {\n
        v8 = cgc_skipWhiteSpace(a0);\n
        if (!cgc_atChar(a0, 123))\n
        {\n
            cgc_printf(\"!!Failed to locate opening brace\\n
\", 123, a2, a3, a4);\n
            v11 = v9;\n
            return v11;\n
        }\n
        if (cgc_skipLength(a0, 1) == -1)\n
        {\n
            cgc_printf(\"!!Failed to skip opening brace\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v11;\n
        }\n
        v8 = cgc_skipWhiteSpace(a0);\n
        v7 = cgc_skipAlpha(a0);\n
        if (v7 == -1)\n
        {\n
            cgc_printf(\"!!Failed to locate the end of the element id\\n
\", 1, a2, a3, a4);\n
            v11 = v9;\n
            return v11;\n
        }\n
        v10 = cgc_copyData(a0, v8, v7);\n
        if (!v10)\n
        {\n
            cgc_printf(\"!!Copy from @d to @d failed\\n
\", v8, v7, a3, a4);\n
        }\n
        else\n
        {\n
            if (cgc_strcmp(v10, \"Established\"))\n
            {\n
                cgc_printf(\"!!Element id is not \\\"Established\\\"\\n
\", \"Established\", a2, a3, a4);\n
                v4 = v10;\n
                cgc_strlen(v10);\n
                cgc_deallocate(a0, \"Established\");\n
                v10 = 0;\n
                v11 = v9;\n
                return v11;\n
            }\n
            v3 = v10;\n
            cgc_strlen(v10);\n
            cgc_deallocate(a0, \"Established\");\n
            cgc_skipWhiteSpace(a0);\n
            if (!cgc_atChar(a0, 125))\n
            {\n
                cgc_printf(\"!!Failed to locate initial closing brace\\n
\", 125, a2, a3, a4);\n
            }\n
            else\n
            {\n
                if (cgc_skipLength(a0, 1) == -1)\n
                {\n
                    cgc_printf(\"!!Failed to skip initial closing brace\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v11;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                cgc_getIndex(a0, &v6);\n
                v5 = cgc_skipInt(a0);\n
                if (v5 == -1)\n
                {\n
                    cgc_printf(\"!!Failed to locate the end of the established data\\n
\", 1, a2, a3, a4);\n
                    v11 = v9;\n
                    return v11;\n
                }\n
                cgc_skipWhiteSpace(a0);\n
                if (!cgc_atChar(a0, 123))\n
                {\n
                    cgc_printf(\"!!Failed to locate the final opening brace\\n
\", 123, a2, a3, a4);\n
                }\n
                else\n
                {\n
                    if (cgc_incChar(a0) == -1)\n
                    {\n
                        cgc_printf(\"!!Failed to skip the final opening brace\\n
\", 123, a2, a3, a4);\n
                        v11 = v9;\n
                        return v11;\n
                    }\n
                    cgc_skipWhiteSpace(a0);\n
                    if (!cgc_atChar(a0, 35))\n
                    {\n
                        cgc_printf(\"!!Failed to locate the closing mark\\n
\", 35, a2, a3, a4);\n
                    }\n
                    else\n
                    {\n
                        v8 = cgc_skipLength(a0, 1);\n
                        if (v8 == -1)\n
                        {\n
                            cgc_printf(\"!!Failed to skip closing mark\\n
\", 1, a2, a3, a4);\n
                            v11 = v9;\n
                            return v11;\n
                        }\n
                        v7 = cgc_skipToNonAlphaNum(a0);\n
                        if (v7 == -1)\n
                        {\n
                            cgc_printf(\"!!Failed to locate the end of the closing element id\\n
\", 1, a2, a3, a4);\n
                        }\n
                        else\n
                        {\n
                            v10 = cgc_copyData(a0, v8, v7);\n
                            if (cgc_strcmp(v10, \"Established\"))\n
                            {\n
                                v2 = v10;\n
                                cgc_strlen(v10);\n
                                cgc_deallocate(a0, \"Established\");\n
                                v11 = v9;\n
                                return v11;\n
                            }\n
                            v1 = v10;\n
                            cgc_strlen(v10);\n
                            cgc_deallocate(a0, \"Established\");\n
                            cgc_skipWhiteSpace(a0);\n
                            if (!cgc_atChar(a0, 125))\n
                            {\n
                                cgc_printf(\"!!Failed to locate final closing brace\\n
\", 125, a2, a3, a4);\n
                            }\n
                            else\n
                            {\n
                                cgc_skipLength(a0, 1);\n
                                v10 = cgc_copyData(a0, v6, v5);\n
                                if (v10)\n
                                {\n
                                    v9 = cgc_atoi(v10);\n
                                    v0 = v10;\n
                                    cgc_strlen(v10);\n
                                    cgc_deallocate(a0, a1);\n
                                    v11 = v9;\n
                                    return v11;\n
                                }\n
                                cgc_printf(\"!!Failed to copy established data\\n
\", a1, a2, a3, a4);\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
    }\n
    v11 = 0;\n
    return v11;\n
}\n
", "4257948:_fini": "long long _fini()\n
{\n
    unsigned long v1;  // rax\n
\n
    return v1;\n
}\n
", "5242880:__libc_start_main": null, "5242888:cgc_pow": null, "5242896:cgc__terminate": null, "5242904:cgc_transmit": null, "5242912:cgc_allocate": null, "5242920:cgc_rint": null, "5242928:cgc_deallocate": null, "5242936:cgc_log10": null, "5242944:cgc_receive": null, "6295632:UnresolvableJumpTarget": null, "6295640:UnresolvableCallTarget": null}