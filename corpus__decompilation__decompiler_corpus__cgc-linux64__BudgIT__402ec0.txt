typedef struct struct_0 {
    char padding_0[8];
    struct struct_0 *field_8;
    unsigned int field_10;
} struct_0;

extern unsigned long long cgc_allocated;
extern unsigned int cgc_curleft;
extern struct_0 *cgc_freed;
extern char cgc_heapinit_done;
extern struct_0 *cgc_lastpage;

long long cgc_malloc(unsigned long long a0)
{
    char v0;  // [bp-0x21]
    struct_0 *v1;  // [bp-0x20]
    unsigned long long v2;  // [bp-0x18]
    void* v3;  // [bp-0x10], Other Possible Types: unsigned long long
    unsigned long long v5;  // 4102

    v2 = a0;
    if (!cgc_heapinit_done)
        cgc_heapinit();
    if (!v2)
    {
        v3 = 0;
        v3 = v3;
        return v3;
    }
    v1 = cgc_freed;
    v2 += 24;
    while (true)
    {
        v5 = v2;
        v0 = 0;
        if (v1->field_10 < v5)
            v0 = v1->field_8 != cgc_freed;
        if (!(v0 & 1))
            break;
        v1 = v1->field_8;
    }
    if (v1->field_10 >= v2)
    {
        cgc_remove(v1);
        cgc_insert(cgc_allocated, v1);
        v3 = &v1[1].padding_0[4];
        s_10 = v3;
        return v3;
    }
    else if (v2 <= cgc_curleft)
    {
        v1 = cgc_lastpage;
        v1->field_10 = v2;
        cgc_lastpage = &cgc_lastpage->padding_0[v2];
        cgc_curleft = cgc_curleft - v2;
        cgc_insert(cgc_allocated, v1);
        v3 = &v1[1].padding_0[4];
        v3 = v3;
        return v3;
    }
    else
    {
        if (cgc_curleft > 24)
        {
            v1 = cgc_lastpage;
            v1->field_10 = cgc_curleft;
            cgc_insert(cgc_freed, v1);
        }
        if (cgc_allocate(v2, 0, &v1))
        {
            v3 = 0;
            v3 = v3;
            return v3;
        }
        v1->field_10 = v2;
        cgc_insert(cgc_allocated, v1);
        cgc_lastpage = &v1->padding_0[v2];
        if ((v2 & 4095))
            cgc_curleft = 0x1000 - (v2 & 4095);
        else
            cgc_curleft = 0;
        v3 = &v1[1].padding_0[4];
        v3 = v3;
        return v3;
    }
}
